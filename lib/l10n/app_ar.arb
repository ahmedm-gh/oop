{
    "@@locale": "ar",
    "appTitle": "إتقان البرمجة الكائنية (OOP Mastery)",
    "home": "الرئيسية",
    "designPatterns": "أنماط التصميم",
    "refactoring": "إعادة هيكلة الكود",
    "interviewQuestions": "أسئلة المقابلات",
    "darkMode": "الوضع الداكن",
    "lightMode": "الوضع الفاتح",
    "language": "اللغة",
    "creationalPatterns": "الأنماط الإنشائية - أنماط إنشاء الكائنات (Creational Patterns)",
    "creationalPatternsDesc": "هذه الأنماط تساعدك في إنشاء الكائنات (Objects) بطرق مرنة ومنظمة، بحيث يكون الكود الخاص بك مستقلاً عن كيفية إنشاء هذه الكائنات.",
    "factoryMethod": "نمط المصنع (Factory Method)",
    "factoryMethodDesc": "يوفر لك طريقة مركزية لإنشاء الكائنات في الكلاس الأب، لكن يسمح للكلاسات الفرعية (Subclasses) أن تقرر نوع الكائن الذي سيتم إنشاؤه بالضبط.",
    "abstractFactory": "المصنع المجرد (Abstract Factory)",
    "abstractFactoryDesc": "يسمح لك بإنشاء مجموعة من الكائنات المرتبطة ببعضها (مثل أزرار ونوافذ بنفس الستايل) دون الحاجة لتحديد الكلاسات الفعلية (Concrete Classes) لهذه الكائنات.",
    "builder": "نمط البناء (Builder)",
    "builderDesc": "يساعدك في بناء كائنات معقدة خطوة بخطوة. مفيد جداً عندما يكون لديك كائن بإعدادات كثيرة ومختلفة، ويتيح لك إنشاء أشكال مختلفة من نفس الكائن باستخدام نفس طريقة البناء.",
    "prototype": "نمط النسخ (Prototype)",
    "prototypeDesc": "يتيح لك نسخ (Clone) الكائنات الموجودة بدلاً من إنشائها من الصفر، دون أن يعتمد الكود الخاص بك على تفاصيل هذه الكائنات الداخلية.",
    "singleton": "نمط الكائن الوحيد (Singleton)",
    "singletonDesc": "يضمن أن الكلاس سيكون له نسخة واحدة فقط (Instance واحد) في البرنامج كله، مع توفير نقطة وصول عامة لهذه النسخة من أي مكان في الكود.",
    "structuralPatterns": "الأنماط الهيكلية - أنماط تنظيم الكائنات (Structural Patterns)",
    "structuralPatternsDesc": "هذه الأنماط تشرح كيفية تجميع وربط الكائنات والكلاسات معاً لتكوين هياكل أكبر، مع الحفاظ على مرونة وكفاءة هذه الهياكل.",
    "adapter": "نمط المحول (Adapter)",
    "adapterDesc": "يسمح لكائنات ذات واجهات (Interfaces) غير متوافقة بالعمل معاً. يعمل مثل محول الكهرباء الذي يوصل قابس بمنفذ غير متطابق معه.",
    "bridge": "نمط الجسر (Bridge)",
    "bridgeDesc": "يفصل الواجهة (Abstraction) عن التنفيذ الفعلي (Implementation)، بحيث يمكن تطوير كل منهما بشكل مستقل. مفيد عندما يكون لديك كلاس كبير يحتوي على عدة نسخ مختلفة من نفس الوظيفة.",
    "composite": "نمط التركيب الهرمي (Composite)",
    "compositeDesc": "يتيح لك تنظيم الكائنات في هياكل شجرية (مثل المجلدات والملفات)، ثم التعامل مع هذه الهياكل كما لو كانت كائناً واحداً فقط.",
    "decorator": "نمط المُغلِّف (Decorator)",
    "decoratorDesc": "يتيح لك إضافة وظائف وسلوكيات جديدة للكائنات أثناء التشغيل (Runtime) عن طريق وضعها داخل كائنات مُغلِّفة خاصة تحتوي على هذه الوظائف الإضافية.",
    "facade": "نمط الواجهة المبسطة (Facade)",
    "facadeDesc": "يوفر واجهة بسيطة وسهلة للتعامل مع مكتبة أو نظام معقد يحتوي على الكثير من الكلاسات والوظائف المعقدة.",
    "flyweight": "نمط توفير الذاكرة (Flyweight)",
    "flyweightDesc": "يوفر استهلاك الذاكرة (RAM) من خلال مشاركة الأجزاء المتشابهة بين الكائنات بدلاً من تخزين جميع البيانات في كل كائن على حدة. مفيد عندما يكون لديك آلاف الكائنات المتشابهة.",
    "proxy": "نمط الوكيل (Proxy)",
    "proxyDesc": "يوفر كائن بديل أو وسيط للكائن الأصلي. يتحكم هذا الوكيل في الوصول للكائن الأصلي، مما يسمح لك بتنفيذ عمليات إضافية قبل أو بعد الوصول إليه (مثل التحقق من الصلاحيات أو التخزين المؤقت).",
    "behavioralPatterns": "الأنماط السلوكية - أنماط التواصل بين الكائنات (Behavioral Patterns)",
    "behavioralPatternsDesc": "تهتم هذه الأنماط بكيفية تواصل وتفاعل الكائنات مع بعضها البعض، وتوزيع المسؤوليات بينها.",
    "chainOfResponsibility": "نمط سلسلة المسؤولية (Chain of Responsibility)",
    "chainOfResponsibilityDesc": "يتيح لك تمرير الطلب على طول سلسلة من الكائنات المعالجة. كل كائن في السلسلة يقرر إما معالجة الطلب بنفسه أو تمريره للكائن التالي في السلسلة.",
    "command": "نمط الأمر (Command)",
    "commandDesc": "يحول الطلب أو العملية إلى كائن مستقل يحتوي على جميع المعلومات عن هذا الطلب. هذا يسمح لك بتمرير الطلبات كمعاملات (Parameters)، وتأخير تنفيذها، أو عمل Undo/Redo.",
    "iterator": "نمط المكرر (Iterator)",
    "iteratorDesc": "يتيح لك المرور على عناصر مجموعة ما (Collection) بدون الحاجة لمعرفة تفاصيل تركيبها الداخلي (سواء كانت List أو Stack أو Tree).",
    "interpreter": "نمط المفسر (Interpreter)",
    "interpreterDesc": "يُستخدم لتفسير لغة أو قواعد محددة (Grammar). يحدد تمثيلاً لقواعد اللغة مع مفسر يستخدم هذا التمثيل لتنفيذ الجمل في هذه اللغة.",
    "mediator": "نمط الوسيط (Mediator)",
    "mediatorDesc": "يقلل من التعقيد والترابط الفوضوي بين الكائنات. يمنع الكائنات من الاتصال المباشر ببعضها، ويجبرها على التواصل فقط من خلال كائن وسيط مركزي.",
    "memento": "نمط حفظ الحالة (Memento)",
    "mementoDesc": "يتيح لك حفظ واستعادة الحالة السابقة لكائن ما (Snapshot) دون الكشف عن تفاصيل تركيبه الداخلي. مفيد لعمل Undo/Redo.",
    "observer": "نمط المراقب (Observer)",
    "observerDesc": "يتيح لك إنشاء نظام اشتراكات (Subscription) لإخطار عدة كائنات تلقائياً عند حدوث تغيير في الكائن الذي يراقبونه. مثل زر الاشتراك في اليوتيوب.",
    "state": "نمط الحالة (State)",
    "stateDesc": "يسمح للكائن بتغيير سلوكه تماماً عندما تتغير حالته الداخلية (State). يبدو الأمر كأن الكائن قد تحول إلى كلاس مختلف تماماً.",
    "strategy": "نمط الاستراتيجية (Strategy)",
    "strategyDesc": "يتيح لك تعريف مجموعة من الخوارزميات (Algorithms) المختلفة، ووضع كل واحدة في كلاس منفصل، بحيث يمكن تبديلها واستخدامها بشكل تبادلي أثناء التشغيل.",
    "templateMethod": "نمط القالب (Template Method)",
    "templateMethodDesc": "يحدد الهيكل العام للخوارزمية في الكلاس الأب، لكن يترك للكلاسات الفرعية حرية تخصيص بعض خطوات محددة من الخوارزمية دون تغيير هيكلها العام.",
    "visitor": "نمط الزائر (Visitor)",
    "visitorDesc": "يتيح لك فصل الخوارزميات والعمليات عن الكائنات التي تعمل عليها. مفيد عندما تريد تنفيذ عمليات مختلفة على مجموعة من الكائنات دون تعديل هذه الكائنات نفسها.",
    "refactoringCategories": "أقسام إعادة هيكلة الكود (Refactoring)",
    "composingMethods": "تنظيم الدوال (Composing Methods)",
    "composingMethodsDesc": "جزء كبير من إعادة الهيكلة يركز على تنظيم الدوال (Methods/Functions) بشكل صحيح. في معظم الحالات، الدوال الطويلة جداً هي السبب الرئيسي للمشاكل في الكود.",
    "movingFeatures": "نقل الوظائف بين الكلاسات (Moving Features)",
    "movingFeaturesDesc": "هذه التقنيات توضح كيفية نقل الدوال والخصائص بأمان بين الكلاسات المختلفة، وإنشاء كلاسات جديدة، وإخفاء التفاصيل الداخلية (Encapsulation).",
    "organizingData": "تنظيم البيانات (Organizing Data)",
    "organizingDataDesc": "تساعدك هذه التقنيات في التعامل الأفضل مع البيانات، واستبدال المتغيرات البسيطة (Primitives مثل String, int) بكائنات وكلاسات أكثر قوة ومرونة.",
    "simplifyingConditionals": "تبسيط الشروط (Simplifying Conditionals)",
    "simplifyingConditionalsDesc": "الشروط (if/else/switch) تميل إلى أن تصبح معقدة ومتشابكة بمرور الوقت. هذه التقنيات تساعدك في جعلها أبسط وأسهل للفهم.",
    "simplifyingMethodCalls": "تبسيط استدعاء الدوال (Simplifying Method Calls)",
    "simplifyingMethodCallsDesc": "هذه التقنيات تجعل طريقة استدعاء واستخدام الدوال أبسط وأوضح وأسهل في الفهم.",
    "generalization": "التعميم والوراثة (Generalization)",
    "generalizationDesc": "يتعلق بشكل أساسي بنقل الوظائف والخصائص صعوداً أو نزولاً في التسلسل الهرمي للوراثة (Inheritance Hierarchy) بين الكلاسات.",
    "notes": "ملاحظات",
    "details": "التفاصيل",
    "example": "مثال بلغة Dart",
    "goodExample": "مثال جيد ✓",
    "badExample": "مثال سيء ✗",
    "seeMore": "عرض المزيد",
    "reference": "المرجع",
    "references": "المراجع",
    "pros": "المميزات",
    "cons": "العيوب",
    "whenToUse": "متى تستخدمه؟",
    "bestUse": "أفضل حالات الاستخدام",
    "close": "إغلاق",
    "extractMethod": "استخراج دالة منفصلة (Extract Method)",
    "inlineMethod": "دمج الدالة في المكان المستدعى منه (Inline Method)",
    "extractVariable": "استخراج متغير منفصل (Extract Variable)",
    "moveMethod": "نقل الدالة لكلاس آخر (Move Method)",
    "moveField": "نقل الخاصية لكلاس آخر (Move Field)",
    "extractClass": "استخراج كلاس جديد منفصل (Extract Class)",
    "selfEncapsulateField": "تغليف الخاصية بـ Getters/Setters (Self Encapsulate Field)",
    "replaceDataValueWithObject": "استبدال المتغير البسيط بكائن (Replace Data Value with Object)",
    "refactoringTip": "هذه التقنية تساعد في تبسيط بنية الكود وتحسين سهولة صيانته وتطويره.",
    "copied": "تم النسخ إلى الحافظة!",
    "singletonNote": "يجب أن يحتوي نمط Singleton على Constructor خاص (Private) ونقطة وصول ثابتة (Static) للنسخة الوحيدة.",
    "factoryMethodNote": "تجنب استخدام سلسلة if-else الطويلة لإنشاء الكائنات؛ بدلاً من ذلك، استخدم الكلاسات الفرعية (Subclasses) لتحديد النوع الفعلي للكائن.",
    "builderNote": "نمط Builder يحل مشكلة 'الـ Constructor الطويل' الذي يحتوي على عدد كبير جداً من الـ Parameters، ويوفر كوداً سهل القراءة والفهم.",
    "singletonPros": "التحكم الكامل في الوصول للنسخة الوحيدة من الكائن\nتجنب استخدام المتغيرات العامة (Global Variables) وتقليل التعارضات\nيسمح بتحسين وتطوير الكلاس من خلال الوراثة (Subclassing)\nيمكن تعديله لاحقاً للسماح بعدة نسخ إذا تغيرت المتطلبات",
    "singletonCons": "ينتهك مبدأ المسؤولية الواحدة (Single Responsibility Principle) لأنه يتحكم في إنشائه بنفسه\nقد يخفي تصميماً سيئاً حيث تعرف الأجزاء المختلفة من البرنامج الكثير عن بعضها\nيحتاج معالجة خاصة في البيئات متعددة الخيوط (Multi-threading)\nصعب في الاختبار (Unit Testing) بسبب الحالة العامة (Global State)",
    "singletonWhenToUse": "استخدمه عندما يجب أن يكون لديك نسخة واحدة فقط من كلاس معين متاحة لجميع أجزاء البرنامج (مثل الاتصال بقاعدة البيانات أو نظام إدارة الملفات).",
    "singletonBestUse": "خدمات التسجيل والـ Logging، إدارة الاتصالات بقاعدة البيانات (Connection Pools)، إدارة الإعدادات (Settings Manager)، أو التحكم في الأجهزة.",
    "factoryMethodPros": "يتجنب الارتباط الشديد (Tight Coupling) بين الكود المُنشئ للكائنات والكائنات نفسها\nمبدأ المسؤولية الواحدة: كل كود إنشاء الكائنات في مكان واحد\nمبدأ المفتوح/المغلق: يمكنك إضافة أنواع جديدة من الكائنات دون تعديل الكود الموجود",
    "factoryMethodCons": "قد يصبح الكود أكثر تعقيداً لأنك تحتاج لإنشاء العديد من الكلاسات الفرعية الجديدة لتطبيق هذا النمط",
    "factoryMethodWhenToUse": "استخدمه عندما لا تعرف مسبقاً الأنواع الدقيقة للكائنات التي سيحتاجها الكود الخاص بك، أو عندما يتم تحديد النوع في وقت التشغيل (Runtime).",
    "factoryMethodBestUse": "أطر عمل واجهة المستخدم (UI Frameworks)، أو أي نظام يتم فيه تحديد نوع الكائن الدقيق أثناء تشغيل البرنامج.",
    "abstractFactoryPros": "يضمن توافق الكائنات المُنشأة مع بعضها (مثل أزرار ونوافذ بنفس الستايل)\nيتجنب الارتباط الشديد بين الكود والكائنات\nمبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق",
    "abstractFactoryCons": "يزيد من تعقيد الكود بسبب إضافة العديد من الـ Interfaces والكلاسات الجديدة",
    "abstractFactoryWhenToUse": "استخدمه عندما يحتاج الكود للتعامل مع مجموعات مختلفة من الكائنات المرتبطة (Families)، ولكن دون الاعتماد على الكلاسات الفعلية لهذه الكائنات.",
    "abstractFactoryBestUse": "مكتبات واجهة المستخدم عبر المنصات المختلفة (Windows/Android/iOS)، أو دعم عدة ثيمات (Themes) مختلفة في التطبيق.",
    "builderPros": "بناء الكائنات خطوة بخطوة بطريقة واضحة\nإعادة استخدام نفس كود البناء لإنشاء أشكال مختلفة من الكائن\nمبدأ المسؤولية الواحدة (عزل كود البناء المعقد في مكان واحد)",
    "builderCons": "يزيد من التعقيد العام للكود بسبب إضافة كلاسات جديدة متعددة",
    "builderWhenToUse": "استخدمه للتخلص من الـ Constructor الذي يحتوي على عدد كبير من الـ Parameters، أو عندما تحتاج لإنشاء أشكال مختلفة من نفس الكائن.",
    "builderBestUse": "الإعدادات المعقدة (Configuration)، بناء المستندات (HTML/JSON/PDF Builders)، أو نماذج البيانات المعقدة (Complex Data Models).",
    "prototypePros": "نسخ الكائنات دون الارتباط بالكلاسات الفعلية (Concrete Classes)\nالتخلص من كود التهيئة المتكرر (Initialization Code)\nإنشاء كائنات معقدة بشكل أسرع وأسهل",
    "prototypeCons": "نسخ الكائنات المعقدة التي تحتوي على مراجع دائرية (Circular References) قد يكون صعباً",
    "prototypeWhenToUse": "استخدمه عندما تكون تكلفة إنشاء كائن جديد من الصفر أعلى من نسخ كائن موجود بالفعل.",
    "prototypeBestUse": "محركات الألعاب (إنشاء وحدات متشابهة)، برامج الجرافيك والتصميم، أو التخزين المؤقت للكائنات (Object Caching).",
    "adapterPros": "مبدأ المسؤولية الواحدة (فصل كود تحويل الواجهة عن باقي الكود)\nمبدأ المفتوح/المغلق (إضافة محولات جديدة دون تعديل كود العميل)",
    "adapterCons": "زيادة في تعقيد الكود بسبب إضافة طبقات جديدة",
    "adapterWhenToUse": "استخدمه عندما تريد استخدام كلاس موجود بالفعل، لكن واجهته (Interface) غير متوافقة مع باقي الكود الخاص بك.",
    "adapterBestUse": "دمج مكتبات الطرف الثالث (3rd Party Libraries)، ترحيل الكود القديم (Legacy Code Migration)، أو تحويل بيانات XML/JSON.",
    "bridgePros": "فصل الواجهة (Abstraction) عن التنفيذ الفعلي (Implementation)\nكتابة كود مستقل عن المنصة (Platform-Independent)\nمبدأ المفتوح/المغلق",
    "bridgeCons": "قد يزيد من تعقيد الكود في حالة الكلاسات البسيطة والمترابطة بشكل جيد",
    "bridgeWhenToUse": "استخدمه عندما تريد تقسيم كلاس كبير ومعقد يحتوي على عدة نسخ مختلفة من نفس الوظيفة إلى أجزاء منفصلة يمكن تطويرها بشكل مستقل.",
    "bridgeBestUse": "أطر عمل الواجهات الرسومية (GUI Frameworks)، تطوير برامج تعمل على منصات مختلفة (Cross-Platform Drivers)، أو مكتبات الجرافيك.",
    "compositePros": "التعامل مع الهياكل الشجرية المعقدة بسهولة\nمبدأ المفتوح/المغلق",
    "compositeCons": "من الصعب توفير واجهة موحدة للكلاسات التي تختلف وظائفها بشكل كبير",
    "compositeWhenToUse": "استخدمه عندما تحتاج لتمثيل هيكل هرمي يشبه الشجرة (Tree-like Structure) مثل نظام الملفات والمجلدات.",
    "compositeBestUse": "أنظمة الملفات (File Systems)، التسلسل الهرمي لمكونات واجهة المستخدم (UI Component Hierarchies)، أو هياكل XML/HTML.",
    "decoratorPros": "إضافة وظائف جديدة للكائن دون إنشاء كلاس فرعي جديد\nإضافة أو إزالة المسؤوليات من الكائن أثناء التشغيل (Runtime)\nدمج عدة وظائف بتغليف الكائن في عدة Decorators",
    "decoratorCons": "من الصعب إزالة Wrapper معين من مجموعة Wrappers متداخلة\nمن الصعب التحكم في سلوك الـ Decorator بحيث لا يعتمد على ترتيبه في مكدس الـ Decorators",
    "decoratorWhenToUse": "استخدمه عندما تحتاج لإضافة سلوكيات ووظائف إضافية للكائنات أثناء التشغيل دون تعديل الكود الذي يستخدم هذه الكائنات.",
    "decoratorBestUse": "معالجة الملفات (I/O Streams)، أنظمة الإشعارات (Notification Systems)، أو إضافة مكونات لواجهة المستخدم (Borders/Scrollbars).",
    "facadePros": "عزل الكود الخاص بك عن تعقيدات النظام الفرعي الداخلية",
    "facadeCons": "قد تصبح الواجهة (Facade) كائناً ضخماً مرتبطاً بجميع أجزاء البرنامج (God Object)",
    "facadeWhenToUse": "استخدمه عندما تحتاج لواجهة بسيطة ومباشرة للتعامل مع نظام فرعي معقد يحتوي على العديد من الكلاسات والدوال.",
    "facadeBestUse": "مكتبات SDK المعقدة للطرف الثالث، مكتبات معالجة الصوت والفيديو، أو التعامل مع عدة APIs في مكان واحد.",
    "proxyPros": "التحكم في كائن الخدمة دون علم المستخدمين (Clients)\nإدارة دورة حياة كائن الخدمة (Life Cycle Management)\nيعمل حتى لو لم يكن كائن الخدمة جاهزاً أو متاحاً بعد",
    "proxyCons": "قد يزيد من تعقيد الكود بسبب إضافة كلاسات جديدة\nقد يتأخر الرد من الخدمة بسبب الطبقة الإضافية",
    "proxyWhenToUse": "استخدمه للتحميل الكسول (Lazy Loading/Virtual Proxy)، التحكم في الصلاحيات (Access Control/Protection Proxy)، أو تسجيل الطلبات (Logging Proxy).",
    "proxyBestUse": "التخزين المؤقت (Caching)، التحكم في الوصول (Access Control)، التحميل البطيء (Lazy Loading)، أو الوصول لخدمات بعيدة (Remote Service Proxy).",
    "observerPros": "مبدأ المفتوح/المغلق\nإنشاء علاقات بين الكائنات أثناء التشغيل (Runtime) بشكل ديناميكي",
    "observerCons": "يتم إخطار المشتركين (Subscribers) بترتيب عشوائي وغير محدد",
    "observerWhenToUse": "استخدمه عندما تحتاج لإخطار عدة كائنات تلقائياً عند حدوث تغيير في كائن معين، خصوصاً عندما لا تعرف مسبقاً عدد أو نوع الكائنات التي ستحتاج للإخطار.",
    "observerBestUse": "أنظمة معالجة الأحداث (Event Handling)، تحديث واجهة المستخدم عند تغير البيانات (UI Updates with Streams/Notifiers)، أو تطبيقات تتبع الأسهم.",
    "strategyPros": "تبديل الخوارزميات أثناء التشغيل (Runtime) بسهولة\nعزل تفاصيل تنفيذ الخوارزمية عن الكود الذي يستخدمها\nمبدأ المفتوح/المغلق",
    "strategyCons": "إذا كان لديك خوارزميتان فقط ونادراً ما تتغيران، فلا داعي لتعقيد البرنامج بكلاسات جديدة",
    "strategyWhenToUse": "استخدمه عندما تريد استخدام أشكال مختلفة من خوارزمية معينة داخل كائن، والقدرة على التبديل بينها أثناء تشغيل البرنامج.",
    "strategyBestUse": "طرق الدفع المختلفة (Payment Methods)، خوارزميات الترتيب (Sorting Algorithms)، تخطيط المسار (Route Planning)، أو أنواع الضغط المختلفة (Compression).",
    "commandPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nتنفيذ Undo/Redo بسهولة\nتأجيل تنفيذ العمليات أو جدولتها (Deferred Execution)",
    "commandCons": "يزيد من تعقيد الكود بسبب إضافة طبقة كاملة جديدة بين المُرسل (Sender) والمُستقبِل (Receiver)",
    "commandWhenToUse": "استخدمه عندما تريد تحويل العمليات إلى كائنات يمكن تمريرها وتخزينها، أو جدولة تنفيذها لاحقاً.",
    "commandBestUse": "أزرار واجهة المستخدم (GUI Buttons)، أنظمة Undo/Redo، قوائم انتظار المهام (Task Queues)، أو تسجيل المعاملات (Transaction Logs).",
    "statePros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nتبسيط الكود المعقد المعتمد على الحالة (التخلص من switch/if-else الضخمة)",
    "stateCons": "قد يكون مبالغاً فيه إذا كانت لديك حالات قليلة فقط أو نادراً ما تتغير",
    "stateWhenToUse": "استخدمه عندما يكون لديك كائن يتصرف بشكل مختلف تماماً اعتماداً على حالته الحالية، والحالات كثيرة، والكود الخاص بكل حالة يتغير بشكل متكرر.",
    "stateBestUse": "آلات البيع الذاتي (Vending Machines)، سلوكيات شخصيات الألعاب (Game Characters)، معالجة الطلبات (Order Processing)، أو مشغلات الوسائط (Media Players).",
    "chainOfResponsibilityPros": "التحكم في ترتيب معالجة الطلبات\nمبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق",
    "chainOfResponsibilityCons": "بعض الطلبات قد لا تتم معالجتها إذا لم يتعامل معها أي معالج في السلسلة",
    "chainOfResponsibilityWhenToUse": "استخدمه عندما يُتوقع من برنامجك معالجة أنواع مختلفة من الطلبات بطرق متنوعة، ولكن الأنواع الدقيقة وترتيب الطلبات غير معروف مسبقاً.",
    "chainOfResponsibilityBestUse": "الـ Middleware في أطر عمل الويب، نظام انتشار الأحداث في واجهة المستخدم (Event Bubbling)، أو سلاسل التحقق المتتالية (Sequential Validation).",
    "iteratorPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nيمكنك إيقاف واستكمال التكرار عند الحاجة",
    "iteratorCons": "قد يكون مبالغاً فيه إذا كان التطبيق يعمل فقط مع مجموعات بسيطة (Simple Collections)",
    "iteratorWhenToUse": "استخدمه عندما تحتوي المجموعة على هيكل بيانات معقد داخلياً، ولكنك تريد إخفاء هذا التعقيد عن المستخدمين.",
    "iteratorBestUse": "أنواع المجموعات المخصصة (Custom Collections)، التنقل في المجلدات (Directory Traversal)، أو معالجة تدفق البيانات المعقدة.",
    "interpreterPros": "سهولة تغيير وتوسيع قواعد اللغة (Grammar)\nتنفيذ القواعد بشكل مباشر وسهل الفهم",
    "interpreterCons": "تصبح الصيانة صعبة مع زيادة تعقيد وعدد قواعد اللغة",
    "interpreterWhenToUse": "استخدمه عندما تكون لديك لغة بسيطة تريد تفسيرها، ويمكن تمثيل جملها كأشجار تركيب نحوي (Abstract Syntax Trees).",
    "interpreterBestUse": "تحليل استعلامات SQL، معالجة التعبيرات النمطية (Regular Expressions)، أو حاسبات التعبيرات الرياضية.",
    "mediatorPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nيقلل من الترابط المعقد بين الأجزاء المختلفة من البرنامج",
    "mediatorCons": "بمرور الوقت، قد يتحول الوسيط إلى كائن ضخم مرتبط بكل شيء (God Object)",
    "mediatorWhenToUse": "استخدمه عندما يصعب تعديل بعض الكلاسات لأنها مرتبطة بشكل وثيق جداً مع مجموعة من الكلاسات الأخرى.",
    "mediatorBestUse": "غرف الدردشة (Chat Rooms)، تنسيق نوافذ الحوار في واجهة المستخدم (UI Dialog Coordination)، أو أنظمة التحكم في الحركة الجوية.",
    "mementoPros": "حفظ حالة الكائن دون انتهاك التغليف (Encapsulation)\nتبسيط كود الكائن الأصلي (Originator)",
    "mementoCons": "قد يستهلك الكثير من الذاكرة (RAM) إذا تم إنشاء Snapshots بشكل متكرر جداً",
    "mementoWhenToUse": "استخدمه عندما تريد حفظ صور (Snapshots) لحالة الكائن لتتمكن من استعادة حالته السابقة عند الحاجة.",
    "mementoBestUse": "أنظمة Undo/Redo، نقاط الحفظ في الألعاب (Game Checkpoints)، أو استعادة الإعدادات السابقة (Configuration Rollbacks).",
    "templateMethodPros": "السماح للمستخدمين بتخصيص أجزاء محددة فقط من خوارزمية كبيرة\nسحب الكود المكرر إلى الكلاس الأب",
    "templateMethodCons": "بعض المستخدمين قد يشعرون بالتقييد بسبب الهيكل المحدد للخوارزمية",
    "templateMethodWhenToUse": "استخدمه عندما تريد السماح للمستخدمين بتوسيع خطوات محددة فقط من الخوارزمية، وليس الخوارزمية بأكملها أو هيكلها العام.",
    "templateMethodBestUse": "أطر عمل معالجة البيانات (Data Processing Frameworks)، سكربتات البناء (Build Scripts)، أو نقاط التخصيص في الخوارزميات القياسية.",
    "visitorPros": "مبدأ المفتوح/المغلق\nمبدأ المسؤولية الواحدة\nيمكن للـ Visitor جمع معلومات مفيدة أثناء العمل مع كائنات مختلفة",
    "visitorCons": "تحتاج لتحديث جميع الـ Visitors في كل مرة يتم إضافة أو حذف كلاس من التسلسل الهرمي",
    "visitorWhenToUse": "استخدمه عندما تحتاج لتنفيذ عملية على جميع عناصر هيكل كائن معقد (مثل شجرة كائنات).",
    "visitorBestUse": "تصدير المستندات بصيغ مختلفة، أدوات تحليل الكود (Code Analysis/AST Visitors)، أو العمليات على مجموعات غير متجانسة.",
    "flyweightPros": "توفير كبير في استهلاك الذاكرة (RAM) إذا كان لديك عدد ضخم من الكائنات المتشابهة\nتحسين الأداء العام في الأنظمة التي تعاني من ضيق الذاكرة",
    "flyweightCons": "قد تضحي بالذاكرة مقابل استهلاك أكبر للمعالج (CPU) عند إعادة حساب بعض البيانات\nيصبح الكود أكثر تعقيداً بشكل ملحوظ",
    "flyweightWhenToUse": "استخدمه فقط عندما يجب أن يدعم برنامجك عدداً هائلاً من الكائنات التي بالكاد تتسع لها الذاكرة المتوفرة.",
    "flyweightBestUse": "أنظمة الجسيمات في الألعاب (Particle Systems مثل الدخان والنار)، علامات الخرائط في مجموعات البيانات الضخمة، أو محررات النصوص التي تتعامل مع ملايين الأحرف.",
    "answer": "الإجابة",
    "basicLevel": "مبتدئ",
    "basicLevelDesc": "مفاهيم أساسية يجب على كل مطور Flutter معرفتها.",
    "intermediateLevel": "متوسط",
    "intermediateLevelDesc": "فهم أعمق لميزات Flutter و Dart.",
    "advancedLevel": "متقدم",
    "advancedLevelDesc": "مواضيع متقدمة للمطورين الأكثر خبرة.",
    "expertLevel": "محترف",
    "expertLevelDesc": "مواضيع متقدمة للمطورين الأكثر خبرة.",
    "qWhatIsFlutter": "ما هو Flutter؟",
    "qWhatIsFlutterNotes": "Flutter هو إطار عمل مفتوح المصدر لبناء تطبيقات يتم تجميعها بشكل أصلي (Native) للهواتف المحمولة والويب وسطح المكتب من قاعدة كود واحدة. يستخدم لغة البرمجة Dart ويوفر مجموعة غنية من العناصر (Widgets) القابلة للتخصيص وأدوات للتطوير السريع.",
    "qWhatIsFlutterPros": "أداء عالٍ بفضل التجميع الأصلي (Native Compilation)\nخاصية Hot Reload للتطوير السريع\nقاعدة كود واحدة لمنصات متعددة",
    "qWhatIsFlutterCons": "حجم التطبيق أكبر مقارنة ببعض البدائل\nمكتبات خارجية أقل نسبياً\nتعلم Dart قد يكون تحدياً للمطورين الجدد",
    "qWhatIsFlutterBestUse": "مثالي لبناء تطبيقات متعددة المنصات مع واجهة مستخدم مخصصة وجميلة ودورات تطوير سريعة.",
    "qWhatIsDart": "ما هي لغة Dart ولماذا تُستخدم في Flutter؟",
    "qWhatIsDartNotes": "Dart هي لغة برمجة حديثة وكائنية التوجه (Object-Oriented) مُحسَّنة لبناء واجهات المستخدم، تُستخدم لتطوير تطبيقات Flutter. تُترجَم إلى كود أصلي (Native) للحصول على أداء عالٍ، ولديها ميزات مثل الأمان من القيم الفارغة (Null Safety) ومكتبة قياسية غنية.",
    "qWhatIsDartPros": "سهلة التعلم للمطورين الذين يعرفون لغات مثل C أو Java\nتدعم كلاً من AOT و JIT Compilation\nميزات قوية للأمان من القيم الفارغة (Null Safety)",
    "qWhatIsDartCons": "نظام بيئي أصغر مقارنة بـ JavaScript\nتُستخدم بشكل رئيسي مع Flutter، مما يحد من إعادة استخدامها في الخادم (Server-Side)",
    "qWhatIsDartBestUse": "الأفضل لتطوير تطبيقات Flutter والتطبيقات التي تحتاج أداءً عالياً وإنتاجية للمطور.",
    "qWhatAreWidgets": "ما هي الـ Widgets في Flutter؟",
    "qWhatAreWidgetsNotes": "الـ Widgets هي اللبنات الأساسية لواجهة المستخدم في تطبيق Flutter. كل ما تراه على الشاشة في Flutter هو Widget، والذي يمكن أن يكون Stateless أو Stateful. تصف الـ Widgets كيفية عرض العناصر على الشاشة بطريقة تصريحية (Declarative).",
    "qWhatAreWidgetsPros": "قابلة للتخصيص والتركيب بشكل كبير\nيمكنك بناء واجهات معقدة بدمج عناصر بسيطة\nخاصية Hot Reload تعمل بشكل ممتاز مع شجرة الـ Widgets",
    "qWhatAreWidgetsCons": "التسلسلات الهرمية العميقة للـ Widgets قد تصبح معقدة\nتتطلب فهم دورة حياة الـ Widget لإدارة الحالة بفعالية",
    "qWhatAreWidgetsBestUse": "استخدم الـ Widgets لجميع مكونات واجهة المستخدم؛ استفد من StatelessWidget للأجزاء الثابتة و StatefulWidget للأجزاء التفاعلية.",
    "qStatelessVsStateful": "ما الفرق بين StatelessWidget و StatefulWidget؟",
    "qStatelessVsStatefulNotes": "الـ StatelessWidget لا يمكن تغيير حالته بعد البناء؛ فهو ثابت (Immutable). أما StatefulWidget فلديه حالة قابلة للتغيير (عبر كائن State) يمكن أن تتغير مع الوقت، مما يؤدي إلى إعادة البناء. StatelessWidget أبسط وأفضل أداءً للمحتوى الثابت. StatefulWidget يسمح بواجهة ديناميكية وتفاعلية.",
    "qStatelessVsStatefulPros": "StatelessWidget أبسط وأفضل أداءً للمحتوى الثابت\nStatefulWidget يسمح بواجهة ديناميكية وتفاعلية",
    "qStatelessVsStatefulCons": "StatelessWidget لا يمكنه تحديث الواجهة عند التغييرات\nStatefulWidget يضيف عبء إدارة الحالة وإعادة البناء",
    "qStatelessVsStatefulBestUse": "استخدم StatelessWidget للواجهة التي لا تتغير (مثل النص الثابت)، واستخدم StatefulWidget عندما تحتاج الواجهة للتحديث (مثل النماذج والرسوم المتحركة).",
    "qWhatIsKey": "ما هو الـ Key في Flutter ولماذا يُستخدم؟",
    "qWhatIsKeyNotes": "الـ Key هو معرّف للـ Widgets والـ Elements والـ SemanticsNodes. تحافظ الـ Keys على الحالة وتتحكم في هوية الـ Widget عند تغيير شجرة الـ Widgets (مثل إعادة الترتيب). استخدام الـ Keys يساعد Flutter في مطابقة الـ Widgets بين عمليات البناء.",
    "qWhatIsKeyPros": "استخدام الـ Keys (خاصة UniqueKey أو ValueKey) يساعد في تجنب السلوك غير المتوقع عند إعادة ترتيب أو تغيير قوائم الـ Widgets ديناميكياً",
    "qWhatIsKeyCons": "غالباً ليست ضرورية إلا إذا كنت تدير قوائم widgets ديناميكية\nالإفراط في استخدام الـ Keys قد يعقد الكود",
    "qWhatIsKeyBestUse": "استخدم الـ Keys عندما يكون لديك عدة widgets من نفس النوع وتحتاج للحفاظ على حالتها عند تحركها أو تغيير موقعها.",
    "qHotReloadVsRestart": "اشرح الفرق بين Hot Reload و Hot Restart في Flutter.",
    "qHotReloadVsRestartNotes": "الـ Hot Reload يضخ الكود المحدث في Dart VM الجاري، محافظاً على حالة التطبيق ويجعل تغييرات الواجهة مرئية فوراً تقريباً. أما Hot Restart فيعيد تشغيل التطبيق بالكامل، ويعيد بناء شجرة الـ Widgets ويعيد تهيئة الحالة، وهو أبطأ من Hot Reload.",
    "qHotReloadVsRestartPros": "Hot Reload يسرع تطوير الواجهة بشكل كبير بالحفاظ على الحالة\nHot Restart يضمن إعادة تعيين كاملة، مفيد عند الحاجة لحالة نظيفة",
    "qHotReloadVsRestartCons": "Hot Reload قد لا يعكس التغييرات خارج كود الـ Widget أو الإعداد الأولي\nHot Restart أبطأ ويفقد الحالة الحالية",
    "qHotReloadVsRestartBestUse": "استخدم Hot Reload للتكرار السريع أثناء تطوير الواجهة؛ استخدم Hot Restart عند الحاجة لتطبيق تغييرات تتطلب إعادة تشغيل التطبيق.",
    "qMaterialAppScaffold": "ما هو الغرض من MaterialApp و Scaffold widgets؟",
    "qMaterialAppScaffoldNotes": "MaterialApp هو widget يغلف عدداً من الـ widgets المطلوبة عادةً لتطبيقات Material Design، مثل الثيمات والتنقل. Scaffold يوفر إطاراً لتنفيذ الهيكل البصري الأساسي لـ Material Design (شريط التطبيق، الأدراج، الأوراق السفلية، إلخ).",
    "qMaterialAppScaffoldPros": "MaterialApp يتعامل مع إعدادات التطبيق (الثيم، اللغة، Navigator)\nScaffold يوفر عناصر واجهة قياسية جاهزة للاستخدام",
    "qMaterialAppScaffoldCons": "يفرضان Material Design\nللمظهر المخصص أو التصميم غير Material، يمكن استخدام WidgetsApp أو تخطيط مخصص",
    "qMaterialAppScaffoldBestUse": "استخدم MaterialApp و Scaffold عند تطوير تطبيق Flutter يتبع إرشادات Material Design.",
    "qWidgetLifecycle": "ما هي دورة حياة Widget في Flutter (دورة حياة StatefulWidget)؟",
    "qWidgetLifecycleNotes": "StatefulWidget لديه كائن State تتضمن دورة حياته initState()، didChangeDependencies()، build()، setState()، deactivate()، dispose()، و reassemble (أثناء hot reload). يُستدعى initState مرة واحدة عند إدراج الـ widget في الشجرة؛ build() يُستدعى كثيراً لإعادة الرسم؛ dispose() يُستدعى عند إزالة الـ widget.",
    "qWidgetLifecyclePros": "فهم دورة الحياة ضروري لإدارة الموارد (مثل تهيئة والتخلص من Controllers) والتحكم في إعادة البناء",
    "qWidgetLifecycleCons": "إدارة دورات الحياة المعقدة قد تكون عرضة للأخطاء\nنسيان dispose يمكن أن يسبب تسرب ذاكرة (Memory Leaks)",
    "qWidgetLifecycleBestUse": "استخدم initState للتهيئة لمرة واحدة، build لبناء الواجهة، و dispose لتنظيف الموارد مثل الرسوم المتحركة أو الـ Streams.",
    "qWhatAreMixins": "ما هي الـ Mixins في Dart وكيف تُستخدم؟",
    "qWhatAreMixinsNotes": "الـ Mixins تسمح للـ class باستخدام methods وخصائص من classes متعددة دون الوراثة المتعددة. في Dart، تعرّف mixin بكلمة 'mixin' ثم تستخدمه بكلمة 'with' في تعريف الـ class. مفيدة لإعادة استخدام الكود.",
    "qWhatAreMixinsPros": "توفر طريقة لإضافة وظائف مشتركة لـ classes متعددة دون فرض علاقة وراثة\nتبقي الـ Classes أكثر وحدوية",
    "qWhatAreMixinsCons": "الإفراط في استخدام الـ Mixins قد يؤدي لتسلسلات معقدة وسلوك غير متوقع إذا عدلت عدة mixins نفس الخصائص",
    "qWhatAreMixinsBestUse": "استخدم الـ Mixins عندما تريد مشاركة وظائف (مثل التسجيل، التحقق، إلخ) عبر classes مختلفة دون إنشاء class أساسي.",
    "qExtensionMethods": "ما هي Extension Methods في Dart؟",
    "qExtensionMethodsNotes": "Extension Methods تسمح لك بإضافة methods جديدة (أو getters/setters) للمكتبات أو الـ classes الموجودة دون تعديلها. تُعرّف باستخدام كلمة 'extension'، وهي سهولة نحوية لتوسيع الوظائف.",
    "qExtensionMethodsPros": "تمكن من كتابة كود أنظف بتوسيع وظائف الأنواع المدمجة أو الـ classes (مثل إضافة methods مساعدة لـ String)",
    "qExtensionMethodsCons": "يمكن أن تجعل الكود أصعب في الاكتشاف، لأن الـ methods غير مرئية في تعريف الـ class الأصلي",
    "qExtensionMethodsBestUse": "استخدم extension methods لإضافة دوال مساعدة للأنواع في مشروعك دون إنشاء utility classes.",
    "qListsSetsMaps": "ما هي Lists و Sets و Maps في Dart ومتى تستخدم كلاً منها؟",
    "qListsSetsMapsNotes": "List هي مجموعة مرتبة تسمح بالتكرار؛ استخدمها عندما يهم الترتيب. Set هي مجموعة غير مرتبة من العناصر الفريدة؛ استخدمها عندما تحتاج التفرد. Map هي مخزن key-value؛ استخدمها عندما تحتاج لربط قيم بمفاتيح للبحث السريع.",
    "qListsSetsMapsProsPros": "Lists تسمح بالوصول بالفهرس والترتيب\nSets تضمن عدم التكرار وتوفر فحص عضوية سريع\nMaps توفر بحث سريع بالمفتاح",
    "qListsSetsMapsProsCons": "Lists قد تكون غير فعالة إذا كنت بحاجة لفرض التفرد\nSets لا تحافظ على ترتيب الإدراج\nMaps تستخدم ذاكرة أكثر لكل عنصر من list بسيطة",
    "qListsSetsMapsProsBestUse": "استخدم List لتسلسلات البيانات المرتبة، Set للمجموعات الفريدة، و Map لارتباطات key-value.",
    "qSolidPrinciples": "ما هي مبادئ SOLID وكيف تنطبق على Flutter؟",
    "qSolidPrinciplesNotes": "SOLID تشير لخمسة مبادئ في التصميم الكائني: المسؤولية الواحدة، المفتوح/المغلق، استبدال Liskov، فصل الواجهات، وعكس التبعية. في Flutter، احتفظ بـ widgets/controllers بمسؤولية واحدة، استخدم التجريدات للتبعيات، واجعل الـ classes مفتوحة للتوسعة لكن مغلقة للتعديل.",
    "qSolidPrinciplesPros": "اتباع SOLID يجعل الكود أكثر قابلية للصيانة والاختبار والتوسعة\nلـ Flutter، يشجع الفصل النظيف بين الواجهة والمنطق",
    "qSolidPrinciplesCons": "الالتزام الصارم قد يؤدي لمزيد من التجريد والكود المتكرر\nقد يعقد المشاريع البسيطة إذا بولغ فيه",
    "qSolidPrinciplesBestUse": "استخدم SOLID لهيكلة تطبيقات Flutter الأكبر؛ ابدأ بسيطاً لكن أعد الهيكلة نحو SOLID مع نمو التعقيد.",
    "qBlocPattern": "ما هو نمط BLoC في Flutter؟",
    "qBlocPatternNotes": "BLoC (Business Logic Component) هو نمط معماري يفصل منطق الأعمال عن الواجهة باستخدام Streams. BLoC يكشف streams من البيانات، وwidgets الواجهة تستمع إليها. هذا يجعل الكود أكثر قابلية للاختبار وإعادة الاستخدام.",
    "qBlocPatternPros": "يعزز فصل الاهتمامات وقابلية الاختبار\nيعمل جيداً مع البرمجة التفاعلية (Reactive Programming)\nيبسط إدارة الحالة للتطبيقات المعقدة",
    "qBlocPatternCons": "يضيف كوداً متكرراً (stream controllers، sinks، إلخ)\nقد يكون مبالغاً فيه للتطبيقات البسيطة\nمنحنى التعلم أعلى من setState البسيط",
    "qBlocPatternBestUse": "استخدم BLoC للتطبيقات المتوسطة والكبيرة حيث يكون فصل المنطق مفيداً. للتطبيقات الأصغر، قد تكفي طرق أبسط.",
    "qProviderVsBloc": "ما هو Provider في Flutter وكيف يختلف عن BLoC؟",
    "qProviderVsBlocNotes": "Provider هو غلاف حول InheritedWidget يسهل إدارة الحالة بتوفير والوصول لكائنات الحالة. بعكس BLoC (الذي يستخدم Streams)، Provider غالباً يستخدم ChangeNotifier أو كائنات بسيطة. Provider يبسط تمرير البيانات عبر شجرة الـ widgets.",
    "qProviderVsBlocPros": "خفيف وسهل الاستخدام\nكود أقل من BLoC\nمتكامل جيداً مع Flutter",
    "qProviderVsBlocCons": "لا يفرض نمطاً صارماً، مما قد يؤدي لمنطق حالة متفرق إذا لم يُنظم\nفصل أقل رسمية من BLoC",
    "qProviderVsBlocBestUse": "استخدم Provider لاحتياجات إدارة حالة أبسط أو تطبيقات أصغر. يتكامل جيداً مع Flutter وأسهل للبدء من BLoC.",
    "qFutureVsStream": "ما الفرق بين Future و Stream في Dart؟",
    "qFutureVsStreamNotes": "Future يمثل عملية حسابية غير متزامنة واحدة تكتمل بقيمة أو خطأ. Stream يمثل تسلسل من الأحداث أو البيانات غير المتزامنة عبر الوقت. FutureBuilder يُستخدم لنتائج async لمرة واحدة، StreamBuilder لتدفقات البيانات المستمرة.",
    "qFutureVsStreamPros": "استخدم Future لطلبات HTTP المفردة أو المهام async السريعة\nاستخدم Stream للأحداث مثل رسائل WebSocket، بيانات الحساسات، أو التحديثات الدورية",
    "qFutureVsStreamCons": "Future لا يمكنه التعامل مع قيم متعددة أو تحديثات مستمرة\nStreams تضيف تعقيداً أكثر (المستمعين، الإلغاءات)",
    "qFutureVsStreamBestUse": "استخدم Future عند توقع نتيجة واحدة. استخدم Stream عند الاستماع لنتائج متعددة أو تغييرات عبر الوقت.",
    "qNavigationPushReplace": "كيف تتنقل بين الشاشات في Flutter؟ (push، pushReplacement)",
    "qNavigationPushReplaceNotes": "التنقل في Flutter يستخدم Navigator widget. Navigator.push يضيف route للمكدس (المستخدم يمكنه الضغط على رجوع للعودة). Navigator.pushReplacement يستبدل الـ route الحالي بجديد، مزيلاً السابق من المكدس.",
    "qNavigationPushReplacePros": "push يحتفظ بالشاشة السابقة في الذاكرة (المستخدم يمكنه العودة)\npushReplacement يزيلها (مناسب لشاشات تسجيل الدخول أو التدفقات التي لا تحتاج العودة)",
    "qNavigationPushReplaceCons": "push قد يراكم routes كثيرة إذا لم يُدار (الذاكرة)\npushReplacement يمنع التنقل للخلف لكن يفقد حالة الشاشة السابقة",
    "qNavigationPushReplaceBestUse": "استخدم push للتنقل للأمام العادي. استخدم pushReplacement لاستبدال الشاشات بشكل دائم (مثل بعد تسجيل الدخول أو شاشة البداية).",
    "qNavigator1Vs2": "ما الفرق بين Navigator 1.0 و Navigator 2.0؟",
    "qNavigator1Vs2Notes": "Navigator 1.0 هو API الأمري الكلاسيكي (push/pop بواسطة widget)، بينما Navigator 2.0 هو API تصريحي قائم على URL مع Router و RouteInformationParser. Navigator 2.0 يوفر تحكماً أكبر في URL المتصفح والروابط العميقة.",
    "qNavigator1Vs2Pros": "Navigator 2.0 يمكّن أنماط تنقل الويب والأكثر تعقيداً (الروابط العميقة)",
    "qNavigator1Vs2Cons": "Navigator 2.0 له منحنى تعلم أعلى وكود أكثر\nللتطبيقات البسيطة، Navigator 1.0 أسهل",
    "qNavigator1Vs2BestUse": "استخدم Navigator 2.0 لتطبيقات الويب أو التطبيقات التي تتطلب روابط عميقة وسلوك توجيه مخصص. للتنقل الأساسي، 1.0 كافٍ.",
    "qBuildContext": "ما هو معامل context في method الـ build() في Flutter؟",
    "qBuildContextNotes": "BuildContext هو كائن يمثل موقع widget في شجرة الـ widgets. يُمرر لـ method الـ build ويمكن استخدامه للوصول لبيانات الثيم والترجمة وللعثور على widgets الأسلاف في الشجرة.",
    "qBuildContextPros": "يسمح للـ widgets بالوصول للـ inherited widgets مثل Theme أو MediaQuery\nضروري للتواصل بين الـ widgets",
    "qBuildContextCons": "إساءة استخدام context (مثل استخدامه قبل initState أو في async) قد يؤدي لأخطاء",
    "qBuildContextBestUse": "استخدم context داخل build() للحصول على الثيم أو بيانات موروثة أخرى، أو Navigator للتنقل.",
    "qWhatIsIsolate": "ما هو الـ Isolate في Dart وكيف يُستخدم؟",
    "qWhatIsIsolateNotes": "Isolate هو خيط تنفيذ منفصل لا يشارك الذاكرة مع الـ isolate الرئيسي. له heap ذاكرة خاص به. الاتصال يتم عبر تمرير الرسائل (SendPort/ReceivePort). استخدم isolates للمهام المكثفة للـ CPU لتجنب حجب خيط الواجهة الرئيسي.",
    "qWhatIsIsolatePros": "يمكّن الحوسبة المتوازية الحقيقية في Dart بدون أخطاء التزامن للذاكرة المشتركة\nيحسن الأداء للمهام الثقيلة",
    "qWhatIsIsolateCons": "الاتصال عبر تمرير الرسائل قد يكون معقداً وأبطأ\nبدء isolate له تكلفة؛ غير مناسب للمهام الصغيرة",
    "qWhatIsIsolateBestUse": "استخدم isolates للحسابات المكلفة (معالجة الصور، الحسابات الكبيرة) بعيداً عن الخيط الرئيسي. لمعظم مهام الواجهة، استخدم async/await بدلاً.",
    "qFutureBuilderStreamBuilder": "ما هو FutureBuilder و StreamBuilder ولماذا يُستخدمان في Flutter؟",
    "qFutureBuilderStreamBuilderNotes": "FutureBuilder هو widget يبني نفسه بناءً على آخر snapshot من التفاعل مع Future. StreamBuilder يعيد البناء بالمثل عند وصول أحداث Stream جديدة. يبسطان التعامل مع البيانات غير المتزامنة في الواجهة بدون مستمعين يدويين.",
    "qFutureBuilderStreamBuilderPros": "يسهل تحديث الواجهة بناءً على نتائج async أو بيانات stream\nيتعامل مع حالات الاتصال والـ snapshots تلقائياً",
    "qFutureBuilderStreamBuilderCons": "قد يؤدي لإعادة بناء عند كل حدث\nتحتاج لإدارة الأداء إذا كانت الـ streams متكررة",
    "qFutureBuilderStreamBuilderBestUse": "استخدم FutureBuilder لنداءات async لمرة واحدة (مثل طلبات HTTP) و StreamBuilder للبيانات المستمرة (مثل التحديثات الفورية أو web sockets).",
    "qConstructorFactory": "ما هو الـ Constructor في Dart وما هي factory constructors؟",
    "qConstructorFactoryNotes": "Constructor في Dart هو method خاص لإنشاء كائنات من class. Factory constructor هو نوع خاص من الـ constructor يمكن أن يعيد instance موجود أو subclass. يُعلن عنه بكلمة 'factory'. مفيد لتطبيقات singleton أو cache.",
    "qConstructorFactoryPros": "Factory constructors تسمح بالتحكم في إنشاء الـ instance (مثل تطبيق singletons أو caches)\nيمكن إرجاع أنواع فرعية مختلفة",
    "qConstructorFactoryCons": "Factory constructors لا يمكنها الوصول لـ 'this' ولا تنشئ instance جديد تلقائياً\nتضيف تعقيداً مقارنة بـ constructor عادي",
    "qConstructorFactoryBestUse": "استخدم factory constructors لأنماط مثل singleton أو عندما تحتاج لمنطق مخصص لتحديد أي instance تعيده.",
    "qSingletonPattern": "ما هو نمط Singleton وكيف يمكنك تطبيقه في Dart؟",
    "qSingletonPatternNotes": "Singleton يضمن أن class له instance واحد فقط ويوفر نقطة وصول عامة. في Dart، يمكنك تطبيق singleton باستخدام constructor خاص و instance ثابت. مفيد للـ caches أو الموارد المشتركة.",
    "qSingletonPatternPros": "يضمن instance مشترك واحد عبر التطبيق (مفيد للـ caches، الموارد المشتركة)",
    "qSingletonPatternCons": "الحالة العامة قد تصعب الاختبار وتؤدي لتبعيات مخفية",
    "qSingletonPatternBestUse": "استخدم singleton للـ classes التي تدير حالة أو موارد عامة (مثل مدير الإعدادات أو عميل الشبكة).",
    "qFlutterPerformance": "كيف تحسّن أداء تطبيق Flutter؟",
    "qFlutterPerformanceNotes": "تحسينات أداء Flutter الشائعة تشمل: استخدام const constructors لتجنب إعادة البناء، تقسيم الـ widgets لتقليل نطاق إعادة البناء، استخدام هياكل بيانات فعالة، تقليل طبقات الـ widgets (RepaintBoundary)، وتخزين الصور أو البيانات مؤقتاً. تجنب أحجام الأصول الكبيرة وإعادة البناء المفرطة.",
    "qFlutterPerformancePros": "تطبيق هذه التقنيات يمكن أن يحسن معدلات الإطارات والاستجابة بشكل كبير",
    "qFlutterPerformanceCons": "التحسين المبكر المفرط قد يعقد الكود\nركز على الاختناقات المحددة بالتحليل (Profiling)",
    "qFlutterPerformanceBestUse": "استخدم تحليل الأداء (DevTools) للعثور على الاختناقات. طبق التحسينات مثل const constructors، التخطيط الفعال، ونقل العمل للـ isolates حسب الحاجة.",
    "qRenderingEngine": "ما هو محرك الرسوميات في Flutter وكيف يعمل (مثل Skia، Impeller)؟",
    "qRenderingEngineNotes": "محرك الرسوميات الافتراضي في Flutter هو Skia، مكتبة رسوميات ثنائية الأبعاد بلغة C++. محرك Impeller الأحدث يحسن الأداء ويقلل المشاكل الرسومية على بعض المنصات. هذه المحركات تترجم واجهة Flutter لأوامر رسوميات أصلية على كل منصة.",
    "qRenderingEnginePros": "Skia يوفر رسوميات عالية الجودة وسريعة\nImpeller يحسن استخدام GPU والقابلية للتنبؤ",
    "qRenderingEngineCons": "تفاصيل المحرك مجردة في الغالب\nيجب على المطورين معرفتها للتصحيح فقط\nImpeller لا يزال ينضج على بعض المنصات",
    "qRenderingEngineBestUse": "استفد من تحسينات المحرك عبر تحديثات Flutter. للاحتياجات المتقدمة (مثل shaders مخصصة)، تعلم كيفية استخدام المحرك المناسب.",
    "qFlutterVsReactNative": "قارن Flutter مع React Native: ما هي المميزات والعيوب؟",
    "qFlutterVsReactNativeNotes": "Flutter و React Native كلاهما أطر عمل متعددة المنصات. Flutter يترجم لكود ARM أصلي وله رسوميات خاصة، مما يوفر أداءً عالياً. React Native يستخدم جسر JavaScript للمكونات الأصلية، مما قد يكون أبطأ. واجهة Flutter قابلة للتخصيص بشكل كبير، بينما React Native يستخدم widgets أصلية بمرونة أقل.",
    "qFlutterVsReactNativePros": "Flutter: أداء عالٍ، تحكم كامل بالواجهة، قاعدة كود واحدة\nReact Native: نظام مكتبات أكبر، JavaScript مألوف لمطوري الويب",
    "qFlutterVsReactNativeCons": "Flutter: حجم تطبيق أكبر، Dart أقل شهرة، حزم طرف ثالث أقل\nReact Native: عبء أداء من جسر JS، مشاكل في اتساق الواجهة",
    "qFlutterVsReactNativeBestUse": "استخدم Flutter عندما يكون الأداء والواجهة المخصصة أولوية. استخدم React Native إذا كانت الاستفادة من كود JavaScript الموجود أو النظام البيئي أهم.",
    "qInheritanceVsComposition": "اشرح الوراثة (Inheritance) والتركيب (Composition) في Dart.",
    "qInheritanceVsCompositionNotes": "الوراثة عندما يمتد class من class آخر، موروثاً خصائصه و methods (علاقة 'is-a'). التركيب عندما يتضمن class instances من classes أخرى كحقول (علاقة 'has-a'). التركيب غالباً مفضل للمرونة.",
    "qInheritanceVsCompositionPros": "الوراثة تسهل إعادة استخدام الكود للـ classes ذات الصلة القريبة\nالتركيب يوفر مرونة أكبر وترابط أقل",
    "qInheritanceVsCompositionCons": "الوراثة قد تؤدي لتسلسلات جامدة وترابط شديد\nالتركيب قد يؤدي لكود متكرر أكثر لكنه أكثر قابلية للتكيف",
    "qInheritanceVsCompositionBestUse": "استخدم الوراثة عندما يكون للـ classes تسلسل واضح ويتشاركون سلوكاً. استخدم التركيب لتجميع السلوك من classes متعددة للمرونة.",
    "qWhatIsPolymorphism": "ما هو تعدد الأشكال (Polymorphism) في البرمجة الكائنية؟",
    "qWhatIsPolymorphismNotes": "تعدد الأشكال يعني 'أشكال متعددة'. في Dart، يسمح بمعاملة كائنات من classes مختلفة عبر واجهة مشتركة (مثل methods مُعاد تعريفها في subclasses). دالة يمكن أن تقبل نوع class أساسي وتعمل على أي instance من subclass.",
    "qWhatIsPolymorphismPros": "يجعل الكود أكثر مرونة وقابلية لإعادة الاستخدام بالبرمجة لواجهة أو superclass بدلاً من classes محددة",
    "qWhatIsPolymorphismCons": "قد يجعل الكود أصعب في الفهم إذا أُفرط في استخدامه، لأن نوع الكائن الفعلي أقل وضوحاً",
    "qWhatIsPolymorphismBestUse": "استخدم تعدد الأشكال عندما تريد استخدام واجهة مشتركة (abstract class أو base class) لتطبيقات محددة مختلفة.",
    "search": "ابحث في الأسئلة...",
    "noResults": "لا توجد نتائج",
    "all": "الكل",
    "codeExample": "مثال كود",
    "programmingTerms": "مصطلحات برمجية",
    "usefulPubPackages": "مكتبات مفيدة",
    "tags": "الوسوم",
    "theoretical": "نظري",
    "practical": "تطبيقي",
    "cBasic": "أساسي",
    "cSecurity": "أمان",
    "cOOP": "برمجة كائنية",
    "cSolid": "صلب",
    "cDesignPatterns": "أنماط التصميم",
    "cDataStructures": "هياكل البيانات",
    "cStateManagement": "إدارة الحالة",
    "cPerformance": "أداء",
    "cTesting": "اختبار",
    "cNetworking": "شبكات",
    "cDatabase": "قاعدة بيانات",
    "cArchitecture": "هندسة معمارية",
    "cDartBasics": "أساسيات دارت",
    "cFlutterBasics": "أساسيات فلاتر",
    "cUI": "واجهة المستخدم",
    "cNativePlatform": "منصة أصلية",
    "cAnimations": "رسوم متحركة",
    "cModernFeatures": "ميزات حديثة",
    "cDeployment": "النشر",
    "questionNotFound": "السؤال غير موجود",
    "onlyBookmarked": "فقط المحفوظة",
    "allLevels": "جميع المستويات",
    "commonMistakes": "الأخطاء الشائعة",
    "noPattern": "لا يوجد نمط",
    "pGoF": "الكلاسيكية (GoF)",
    "pNonGoF": "غير مدرجة ضمن GoF",
    "pPractical": "نمط عملي",
    "pModern": "نمط حديث",

    "designPattern": "نمط تصميم",
    "architecturalPattern": "نمط معماري",
    "stateManagementPattern": "نمط إدارة الحالة",
    "uiPattern": "نمط واجهة المستخدم (UI)",
    "projectStructurePattern": "نمط هيكلة المشروع",

    "creationalPattern": "نمط الإنشاء (Creational)",
    "structuralPattern": "نمط التركيب (Structural)",
    "behavioralPattern": "نمط السلوك (Behavioral)",

    "relatedPatterns": "أنماط متعلقة",
    "oftenConfusedWith": "غالباً ما يخطلت الأمر مع"
}