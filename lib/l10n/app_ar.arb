{
    "appTitle": "إتقان البرمجة الكائنية (OOP Mastery)",
    "home": "الرئيسية",
    "designPatterns": "أنماط التصميم",
    "refactoring": "إعادة هيكلة الكود",
    "interviewQuestions": "أسئلة المقابلات",
    "darkMode": "الوضع الداكن",
    "lightMode": "الوضع الفاتح",
    "language": "اللغة",
    
    "creationalPatterns": "الأنماط الإنشائية - أنماط إنشاء الكائنات (Creational Patterns)",
    "creationalPatternsDesc": "هذه الأنماط تساعدك في إنشاء الكائنات (Objects) بطرق مرنة ومنظمة، بحيث يكون الكود الخاص بك مستقلاً عن كيفية إنشاء هذه الكائنات.",
    "factoryMethod": "نمط المصنع (Factory Method)",
    "factoryMethodDesc": "يوفر لك طريقة مركزية لإنشاء الكائنات في الكلاس الأب، لكن يسمح للكلاسات الفرعية (Subclasses) أن تقرر نوع الكائن الذي سيتم إنشاؤه بالضبط.",
    "abstractFactory": "المصنع المجرد (Abstract Factory)",
    "abstractFactoryDesc": "يسمح لك بإنشاء مجموعة من الكائنات المرتبطة ببعضها (مثل أزرار ونوافذ بنفس الستايل) دون الحاجة لتحديد الكلاسات الفعلية (Concrete Classes) لهذه الكائنات.",
    "builder": "نمط البناء (Builder)",
    "builderDesc": "يساعدك في بناء كائنات معقدة خطوة بخطوة. مفيد جداً عندما يكون لديك كائن بإعدادات كثيرة ومختلفة، ويتيح لك إنشاء أشكال مختلفة من نفس الكائن باستخدام نفس طريقة البناء.",
    "prototype": "نمط النسخ (Prototype)",
    "prototypeDesc": "يتيح لك نسخ (Clone) الكائنات الموجودة بدلاً من إنشائها من الصفر، دون أن يعتمد الكود الخاص بك على تفاصيل هذه الكائنات الداخلية.",
    "singleton": "نمط الكائن الوحيد (Singleton)",
    "singletonDesc": "يضمن أن الكلاس سيكون له نسخة واحدة فقط (Instance واحد) في البرنامج كله، مع توفير نقطة وصول عامة لهذه النسخة من أي مكان في الكود.",
    
    "structuralPatterns": "الأنماط الهيكلية - أنماط تنظيم الكائنات (Structural Patterns)",
    "structuralPatternsDesc": "هذه الأنماط تشرح كيفية تجميع وربط الكائنات والكلاسات معاً لتكوين هياكل أكبر، مع الحفاظ على مرونة وكفاءة هذه الهياكل.",
    "adapter": "نمط المحول (Adapter)",
    "adapterDesc": "يسمح لكائنات ذات واجهات (Interfaces) غير متوافقة بالعمل معاً. يعمل مثل محول الكهرباء الذي يوصل قابس بمنفذ غير متطابق معه.",
    "bridge": "نمط الجسر (Bridge)",
    "bridgeDesc": "يفصل الواجهة (Abstraction) عن التنفيذ الفعلي (Implementation)، بحيث يمكن تطوير كل منهما بشكل مستقل. مفيد عندما يكون لديك كلاس كبير يحتوي على عدة نسخ مختلفة من نفس الوظيفة.",
    "composite": "نمط التركيب الهرمي (Composite)",
    "compositeDesc": "يتيح لك تنظيم الكائنات في هياكل شجرية (مثل المجلدات والملفات)، ثم التعامل مع هذه الهياكل كما لو كانت كائناً واحداً فقط.",
    "decorator": "نمط المُغلِّف (Decorator)",
    "decoratorDesc": "يتيح لك إضافة وظائف وسلوكيات جديدة للكائنات أثناء التشغيل (Runtime) عن طريق وضعها داخل كائنات مُغلِّفة خاصة تحتوي على هذه الوظائف الإضافية.",
    "facade": "نمط الواجهة المبسطة (Facade)",
    "facadeDesc": "يوفر واجهة بسيطة وسهلة للتعامل مع مكتبة أو نظام معقد يحتوي على الكثير من الكلاسات والوظائف المعقدة.",
    "flyweight": "نمط توفير الذاكرة (Flyweight)",
    "flyweightDesc": "يوفر استهلاك الذاكرة (RAM) من خلال مشاركة الأجزاء المتشابهة بين الكائنات بدلاً من تخزين جميع البيانات في كل كائن على حدة. مفيد عندما يكون لديك آلاف الكائنات المتشابهة.",
    "proxy": "نمط الوكيل (Proxy)",
    "proxyDesc": "يوفر كائن بديل أو وسيط للكائن الأصلي. يتحكم هذا الوكيل في الوصول للكائن الأصلي، مما يسمح لك بتنفيذ عمليات إضافية قبل أو بعد الوصول إليه (مثل التحقق من الصلاحيات أو التخزين المؤقت).",
    
    "behavioralPatterns": "الأنماط السلوكية - أنماط التواصل بين الكائنات (Behavioral Patterns)",
    "behavioralPatternsDesc": "تهتم هذه الأنماط بكيفية تواصل وتفاعل الكائنات مع بعضها البعض، وتوزيع المسؤوليات بينها.",
    "chainOfResponsibility": "نمط سلسلة المسؤولية (Chain of Responsibility)",
    "chainOfResponsibilityDesc": "يتيح لك تمرير الطلب على طول سلسلة من الكائنات المعالجة. كل كائن في السلسلة يقرر إما معالجة الطلب بنفسه أو تمريره للكائن التالي في السلسلة.",
    "command": "نمط الأمر (Command)",
    "commandDesc": "يحول الطلب أو العملية إلى كائن مستقل يحتوي على جميع المعلومات عن هذا الطلب. هذا يسمح لك بتمرير الطلبات كمعاملات (Parameters)، وتأخير تنفيذها، أو عمل Undo/Redo.",
    "iterator": "نمط المكرر (Iterator)",
    "iteratorDesc": "يتيح لك المرور على عناصر مجموعة ما (Collection) بدون الحاجة لمعرفة تفاصيل تركيبها الداخلي (سواء كانت List أو Stack أو Tree).",
    "interpreter": "نمط المفسر (Interpreter)",
    "interpreterDesc": "يُستخدم لتفسير لغة أو قواعد محددة (Grammar). يحدد تمثيلاً لقواعد اللغة مع مفسر يستخدم هذا التمثيل لتنفيذ الجمل في هذه اللغة.",
    "mediator": "نمط الوسيط (Mediator)",
    "mediatorDesc": "يقلل من التعقيد والترابط الفوضوي بين الكائنات. يمنع الكائنات من الاتصال المباشر ببعضها، ويجبرها على التواصل فقط من خلال كائن وسيط مركزي.",
    "memento": "نمط حفظ الحالة (Memento)",
    "mementoDesc": "يتيح لك حفظ واستعادة الحالة السابقة لكائن ما (Snapshot) دون الكشف عن تفاصيل تركيبه الداخلي. مفيد لعمل Undo/Redo.",
    "observer": "نمط المراقب (Observer)",
    "observerDesc": "يتيح لك إنشاء نظام اشتراكات (Subscription) لإخطار عدة كائنات تلقائياً عند حدوث تغيير في الكائن الذي يراقبونه. مثل زر الاشتراك في اليوتيوب.",
    "state": "نمط الحالة (State)",
    "stateDesc": "يسمح للكائن بتغيير سلوكه تماماً عندما تتغير حالته الداخلية (State). يبدو الأمر كأن الكائن قد تحول إلى كلاس مختلف تماماً.",
    "strategy": "نمط الاستراتيجية (Strategy)",
    "strategyDesc": "يتيح لك تعريف مجموعة من الخوارزميات (Algorithms) المختلفة، ووضع كل واحدة في كلاس منفصل، بحيث يمكن تبديلها واستخدامها بشكل تبادلي أثناء التشغيل.",
    "templateMethod": "نمط القالب (Template Method)",
    "templateMethodDesc": "يحدد الهيكل العام للخوارزمية في الكلاس الأب، لكن يترك للكلاسات الفرعية حرية تخصيص بعض خطوات محددة من الخوارزمية دون تغيير هيكلها العام.",
    "visitor": "نمط الزائر (Visitor)",
    "visitorDesc": "يتيح لك فصل الخوارزميات والعمليات عن الكائنات التي تعمل عليها. مفيد عندما تريد تنفيذ عمليات مختلفة على مجموعة من الكائنات دون تعديل هذه الكائنات نفسها.",
    
    "refactoringCategories": "أقسام إعادة هيكلة الكود (Refactoring)",
    "composingMethods": "تنظيم الدوال (Composing Methods)",
    "composingMethodsDesc": "جزء كبير من إعادة الهيكلة يركز على تنظيم الدوال (Methods/Functions) بشكل صحيح. في معظم الحالات، الدوال الطويلة جداً هي السبب الرئيسي للمشاكل في الكود.",
    "movingFeatures": "نقل الوظائف بين الكلاسات (Moving Features)",
    "movingFeaturesDesc": "هذه التقنيات توضح كيفية نقل الدوال والخصائص بأمان بين الكلاسات المختلفة، وإنشاء كلاسات جديدة، وإخفاء التفاصيل الداخلية (Encapsulation).",
    "organizingData": "تنظيم البيانات (Organizing Data)",
    "organizingDataDesc": "تساعدك هذه التقنيات في التعامل الأفضل مع البيانات، واستبدال المتغيرات البسيطة (Primitives مثل String, int) بكائنات وكلاسات أكثر قوة ومرونة.",
    "simplifyingConditionals": "تبسيط الشروط (Simplifying Conditionals)",
    "simplifyingConditionalsDesc": "الشروط (if/else/switch) تميل إلى أن تصبح معقدة ومتشابكة بمرور الوقت. هذه التقنيات تساعدك في جعلها أبسط وأسهل للفهم.",
    "simplifyingMethodCalls": "تبسيط استدعاء الدوال (Simplifying Method Calls)",
    "simplifyingMethodCallsDesc": "هذه التقنيات تجعل طريقة استدعاء واستخدام الدوال أبسط وأوضح وأسهل في الفهم.",
    "generalization": "التعميم والوراثة (Generalization)",
    "generalizationDesc": "يتعلق بشكل أساسي بنقل الوظائف والخصائص صعوداً أو نزولاً في التسلسل الهرمي للوراثة (Inheritance Hierarchy) بين الكلاسات.",

    "notes": "ملاحظات",
    "details": "التفاصيل",
    "example": "مثال بلغة Dart",
    "goodExample": "مثال جيد ✓",
    "badExample": "مثال سيء ✗",
    "seeMore": "عرض المزيد",
    "reference": "المرجع",
    "references": "المراجع",
    "pros": "المميزات",
    "cons": "العيوب",
    "whenToUse": "متى تستخدمه؟",
    "bestUse": "أفضل حالات الاستخدام",
    "close": "إغلاق",
    "extractMethod": "استخراج دالة منفصلة (Extract Method)",
    "inlineMethod": "دمج الدالة في المكان المستدعى منه (Inline Method)",
    "extractVariable": "استخراج متغير منفصل (Extract Variable)",
    "moveMethod": "نقل الدالة لكلاس آخر (Move Method)",
    "moveField": "نقل الخاصية لكلاس آخر (Move Field)",
    "extractClass": "استخراج كلاس جديد منفصل (Extract Class)",
    "selfEncapsulateField": "تغليف الخاصية بـ Getters/Setters (Self Encapsulate Field)",
    "replaceDataValueWithObject": "استبدال المتغير البسيط بكائن (Replace Data Value with Object)",
    "refactoringTip": "هذه التقنية تساعد في تبسيط بنية الكود وتحسين سهولة صيانته وتطويره.",
    "copied": "تم النسخ إلى الحافظة!",
    "singletonNote": "يجب أن يحتوي نمط Singleton على Constructor خاص (Private) ونقطة وصول ثابتة (Static) للنسخة الوحيدة.",
    "factoryMethodNote": "تجنب استخدام سلسلة if-else الطويلة لإنشاء الكائنات؛ بدلاً من ذلك، استخدم الكلاسات الفرعية (Subclasses) لتحديد النوع الفعلي للكائن.",
    "builderNote": "نمط Builder يحل مشكلة 'الـ Constructor الطويل' الذي يحتوي على عدد كبير جداً من الـ Parameters، ويوفر كوداً سهل القراءة والفهم.",
    "singletonPros": "التحكم الكامل في الوصول للنسخة الوحيدة من الكائن\nتجنب استخدام المتغيرات العامة (Global Variables) وتقليل التعارضات\nيسمح بتحسين وتطوير الكلاس من خلال الوراثة (Subclassing)\nيمكن تعديله لاحقاً للسماح بعدة نسخ إذا تغيرت المتطلبات",
    "singletonCons": "ينتهك مبدأ المسؤولية الواحدة (Single Responsibility Principle) لأنه يتحكم في إنشائه بنفسه\nقد يخفي تصميماً سيئاً حيث تعرف الأجزاء المختلفة من البرنامج الكثير عن بعضها\nيحتاج معالجة خاصة في البيئات متعددة الخيوط (Multi-threading)\nصعب في الاختبار (Unit Testing) بسبب الحالة العامة (Global State)",
    "singletonWhenToUse": "استخدمه عندما يجب أن يكون لديك نسخة واحدة فقط من كلاس معين متاحة لجميع أجزاء البرنامج (مثل الاتصال بقاعدة البيانات أو نظام إدارة الملفات).",
    "singletonBestUse": "خدمات التسجيل والـ Logging، إدارة الاتصالات بقاعدة البيانات (Connection Pools)، إدارة الإعدادات (Settings Manager)، أو التحكم في الأجهزة.",
    "factoryMethodPros": "يتجنب الارتباط الشديد (Tight Coupling) بين الكود المُنشئ للكائنات والكائنات نفسها\nمبدأ المسؤولية الواحدة: كل كود إنشاء الكائنات في مكان واحد\nمبدأ المفتوح/المغلق: يمكنك إضافة أنواع جديدة من الكائنات دون تعديل الكود الموجود",
    "factoryMethodCons": "قد يصبح الكود أكثر تعقيداً لأنك تحتاج لإنشاء العديد من الكلاسات الفرعية الجديدة لتطبيق هذا النمط",
    "factoryMethodWhenToUse": "استخدمه عندما لا تعرف مسبقاً الأنواع الدقيقة للكائنات التي سيحتاجها الكود الخاص بك، أو عندما يتم تحديد النوع في وقت التشغيل (Runtime).",
    "factoryMethodBestUse": "أطر عمل واجهة المستخدم (UI Frameworks)، أو أي نظام يتم فيه تحديد نوع الكائن الدقيق أثناء تشغيل البرنامج.",
    "abstractFactoryPros": "يضمن توافق الكائنات المُنشأة مع بعضها (مثل أزرار ونوافذ بنفس الستايل)\nيتجنب الارتباط الشديد بين الكود والكائنات\nمبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق",
    "abstractFactoryCons": "يزيد من تعقيد الكود بسبب إضافة العديد من الـ Interfaces والكلاسات الجديدة",
    "abstractFactoryWhenToUse": "استخدمه عندما يحتاج الكود للتعامل مع مجموعات مختلفة من الكائنات المرتبطة (Families)، ولكن دون الاعتماد على الكلاسات الفعلية لهذه الكائنات.",
    "abstractFactoryBestUse": "مكتبات واجهة المستخدم عبر المنصات المختلفة (Windows/Android/iOS)، أو دعم عدة ثيمات (Themes) مختلفة في التطبيق.",
    "builderPros": "بناء الكائنات خطوة بخطوة بطريقة واضحة\nإعادة استخدام نفس كود البناء لإنشاء أشكال مختلفة من الكائن\nمبدأ المسؤولية الواحدة (عزل كود البناء المعقد في مكان واحد)",
    "builderCons": "يزيد من التعقيد العام للكود بسبب إضافة كلاسات جديدة متعددة",
    "builderWhenToUse": "استخدمه للتخلص من الـ Constructor الذي يحتوي على عدد كبير من الـ Parameters، أو عندما تحتاج لإنشاء أشكال مختلفة من نفس الكائن.",
    "builderBestUse": "الإعدادات المعقدة (Configuration)، بناء المستندات (HTML/JSON/PDF Builders)، أو نماذج البيانات المعقدة (Complex Data Models).",
    "prototypePros": "نسخ الكائنات دون الارتباط بالكلاسات الفعلية (Concrete Classes)\nالتخلص من كود التهيئة المتكرر (Initialization Code)\nإنشاء كائنات معقدة بشكل أسرع وأسهل",
    "prototypeCons": "نسخ الكائنات المعقدة التي تحتوي على مراجع دائرية (Circular References) قد يكون صعباً",
    "prototypeWhenToUse": "استخدمه عندما تكون تكلفة إنشاء كائن جديد من الصفر أعلى من نسخ كائن موجود بالفعل.",
    "prototypeBestUse": "محركات الألعاب (إنشاء وحدات متشابهة)، برامج الجرافيك والتصميم، أو التخزين المؤقت للكائنات (Object Caching).",
    "adapterPros": "مبدأ المسؤولية الواحدة (فصل كود تحويل الواجهة عن باقي الكود)\nمبدأ المفتوح/المغلق (إضافة محولات جديدة دون تعديل كود العميل)",
    "adapterCons": "زيادة في تعقيد الكود بسبب إضافة طبقات جديدة",
    "adapterWhenToUse": "استخدمه عندما تريد استخدام كلاس موجود بالفعل، لكن واجهته (Interface) غير متوافقة مع باقي الكود الخاص بك.",
    "adapterBestUse": "دمج مكتبات الطرف الثالث (3rd Party Libraries)، ترحيل الكود القديم (Legacy Code Migration)، أو تحويل بيانات XML/JSON.",
    "bridgePros": "فصل الواجهة (Abstraction) عن التنفيذ الفعلي (Implementation)\nكتابة كود مستقل عن المنصة (Platform-Independent)\nمبدأ المفتوح/المغلق",
    "bridgeCons": "قد يزيد من تعقيد الكود في حالة الكلاسات البسيطة والمترابطة بشكل جيد",
    "bridgeWhenToUse": "استخدمه عندما تريد تقسيم كلاس كبير ومعقد يحتوي على عدة نسخ مختلفة من نفس الوظيفة إلى أجزاء منفصلة يمكن تطويرها بشكل مستقل.",
    "bridgeBestUse": "أطر عمل الواجهات الرسومية (GUI Frameworks)، تطوير برامج تعمل على منصات مختلفة (Cross-Platform Drivers)، أو مكتبات الجرافيك.",
    "compositePros": "التعامل مع الهياكل الشجرية المعقدة بسهولة\nمبدأ المفتوح/المغلق",
    "compositeCons": "من الصعب توفير واجهة موحدة للكلاسات التي تختلف وظائفها بشكل كبير",
    "compositeWhenToUse": "استخدمه عندما تحتاج لتمثيل هيكل هرمي يشبه الشجرة (Tree-like Structure) مثل نظام الملفات والمجلدات.",
    "compositeBestUse": "أنظمة الملفات (File Systems)، التسلسل الهرمي لمكونات واجهة المستخدم (UI Component Hierarchies)، أو هياكل XML/HTML.",
    "decoratorPros": "إضافة وظائف جديدة للكائن دون إنشاء كلاس فرعي جديد\nإضافة أو إزالة المسؤوليات من الكائن أثناء التشغيل (Runtime)\nدمج عدة وظائف بتغليف الكائن في عدة Decorators",
    "decoratorCons": "من الصعب إزالة Wrapper معين من مجموعة Wrappers متداخلة\nمن الصعب التحكم في سلوك الـ Decorator بحيث لا يعتمد على ترتيبه في مكدس الـ Decorators",
    "decoratorWhenToUse": "استخدمه عندما تحتاج لإضافة سلوكيات ووظائف إضافية للكائنات أثناء التشغيل دون تعديل الكود الذي يستخدم هذه الكائنات.",
    "decoratorBestUse": "معالجة الملفات (I/O Streams)، أنظمة الإشعارات (Notification Systems)، أو إضافة مكونات لواجهة المستخدم (Borders/Scrollbars).",
    "facadePros": "عزل الكود الخاص بك عن تعقيدات النظام الفرعي الداخلية",
    "facadeCons": "قد تصبح الواجهة (Facade) كائناً ضخماً مرتبطاً بجميع أجزاء البرنامج (God Object)",
    "facadeWhenToUse": "استخدمه عندما تحتاج لواجهة بسيطة ومباشرة للتعامل مع نظام فرعي معقد يحتوي على العديد من الكلاسات والدوال.",
    "facadeBestUse": "مكتبات SDK المعقدة للطرف الثالث، مكتبات معالجة الصوت والفيديو، أو التعامل مع عدة APIs في مكان واحد.",
    "proxyPros": "التحكم في كائن الخدمة دون علم المستخدمين (Clients)\nإدارة دورة حياة كائن الخدمة (Life Cycle Management)\nيعمل حتى لو لم يكن كائن الخدمة جاهزاً أو متاحاً بعد",
    "proxyCons": "قد يزيد من تعقيد الكود بسبب إضافة كلاسات جديدة\nقد يتأخر الرد من الخدمة بسبب الطبقة الإضافية",
    "proxyWhenToUse": "استخدمه للتحميل الكسول (Lazy Loading/Virtual Proxy)، التحكم في الصلاحيات (Access Control/Protection Proxy)، أو تسجيل الطلبات (Logging Proxy).",
    "proxyBestUse": "التخزين المؤقت (Caching)، التحكم في الوصول (Access Control)، التحميل البطيء (Lazy Loading)، أو الوصول لخدمات بعيدة (Remote Service Proxy).",
    "observerPros": "مبدأ المفتوح/المغلق\nإنشاء علاقات بين الكائنات أثناء التشغيل (Runtime) بشكل ديناميكي",
    "observerCons": "يتم إخطار المشتركين (Subscribers) بترتيب عشوائي وغير محدد",
    "observerWhenToUse": "استخدمه عندما تحتاج لإخطار عدة كائنات تلقائياً عند حدوث تغيير في كائن معين، خصوصاً عندما لا تعرف مسبقاً عدد أو نوع الكائنات التي ستحتاج للإخطار.",
    "observerBestUse": "أنظمة معالجة الأحداث (Event Handling)، تحديث واجهة المستخدم عند تغير البيانات (UI Updates with Streams/Notifiers)، أو تطبيقات تتبع الأسهم.",
    "strategyPros": "تبديل الخوارزميات أثناء التشغيل (Runtime) بسهولة\nعزل تفاصيل تنفيذ الخوارزمية عن الكود الذي يستخدمها\nمبدأ المفتوح/المغلق",
    "strategyCons": "إذا كان لديك خوارزميتان فقط ونادراً ما تتغيران، فلا داعي لتعقيد البرنامج بكلاسات جديدة",
    "strategyWhenToUse": "استخدمه عندما تريد استخدام أشكال مختلفة من خوارزمية معينة داخل كائن، والقدرة على التبديل بينها أثناء تشغيل البرنامج.",
    "strategyBestUse": "طرق الدفع المختلفة (Payment Methods)، خوارزميات الترتيب (Sorting Algorithms)، تخطيط المسار (Route Planning)، أو أنواع الضغط المختلفة (Compression).",
    "commandPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nتنفيذ Undo/Redo بسهولة\nتأجيل تنفيذ العمليات أو جدولتها (Deferred Execution)",
    "commandCons": "يزيد من تعقيد الكود بسبب إضافة طبقة كاملة جديدة بين المُرسل (Sender) والمُستقبِل (Receiver)",
    "commandWhenToUse": "استخدمه عندما تريد تحويل العمليات إلى كائنات يمكن تمريرها وتخزينها، أو جدولة تنفيذها لاحقاً.",
    "commandBestUse": "أزرار واجهة المستخدم (GUI Buttons)، أنظمة Undo/Redo، قوائم انتظار المهام (Task Queues)، أو تسجيل المعاملات (Transaction Logs).",
    "statePros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nتبسيط الكود المعقد المعتمد على الحالة (التخلص من switch/if-else الضخمة)",
    "stateCons": "قد يكون مبالغاً فيه إذا كانت لديك حالات قليلة فقط أو نادراً ما تتغير",
    "stateWhenToUse": "استخدمه عندما يكون لديك كائن يتصرف بشكل مختلف تماماً اعتماداً على حالته الحالية، والحالات كثيرة، والكود الخاص بكل حالة يتغير بشكل متكرر.",
    "stateBestUse": "آلات البيع الذاتي (Vending Machines)، سلوكيات شخصيات الألعاب (Game Characters)، معالجة الطلبات (Order Processing)، أو مشغلات الوسائط (Media Players).",
    "chainOfResponsibilityPros": "التحكم في ترتيب معالجة الطلبات\nمبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق",
    "chainOfResponsibilityCons": "بعض الطلبات قد لا تتم معالجتها إذا لم يتعامل معها أي معالج في السلسلة",
    "chainOfResponsibilityWhenToUse": "استخدمه عندما يُتوقع من برنامجك معالجة أنواع مختلفة من الطلبات بطرق متنوعة، ولكن الأنواع الدقيقة وترتيب الطلبات غير معروف مسبقاً.",
    "chainOfResponsibilityBestUse": "الـ Middleware في أطر عمل الويب، نظام انتشار الأحداث في واجهة المستخدم (Event Bubbling)، أو سلاسل التحقق المتتالية (Sequential Validation).",
    "iteratorPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nيمكنك إيقاف واستكمال التكرار عند الحاجة",
    "iteratorCons": "قد يكون مبالغاً فيه إذا كان التطبيق يعمل فقط مع مجموعات بسيطة (Simple Collections)",
    "iteratorWhenToUse": "استخدمه عندما تحتوي المجموعة على هيكل بيانات معقد داخلياً، ولكنك تريد إخفاء هذا التعقيد عن المستخدمين.",
    "iteratorBestUse": "أنواع المجموعات المخصصة (Custom Collections)، التنقل في المجلدات (Directory Traversal)، أو معالجة تدفق البيانات المعقدة.",
    "interpreterPros": "سهولة تغيير وتوسيع قواعد اللغة (Grammar)\nتنفيذ القواعد بشكل مباشر وسهل الفهم",
    "interpreterCons": "تصبح الصيانة صعبة مع زيادة تعقيد وعدد قواعد اللغة",
    "interpreterWhenToUse": "استخدمه عندما تكون لديك لغة بسيطة تريد تفسيرها، ويمكن تمثيل جملها كأشجار تركيب نحوي (Abstract Syntax Trees).",
    "interpreterBestUse": "تحليل استعلامات SQL، معالجة التعبيرات النمطية (Regular Expressions)، أو حاسبات التعبيرات الرياضية.",
    "mediatorPros": "مبدأ المسؤولية الواحدة\nمبدأ المفتوح/المغلق\nيقلل من الترابط المعقد بين الأجزاء المختلفة من البرنامج",
    "mediatorCons": "بمرور الوقت، قد يتحول الوسيط إلى كائن ضخم مرتبط بكل شيء (God Object)",
    "mediatorWhenToUse": "استخدمه عندما يصعب تعديل بعض الكلاسات لأنها مرتبطة بشكل وثيق جداً مع مجموعة من الكلاسات الأخرى.",
    "mediatorBestUse": "غرف الدردشة (Chat Rooms)، تنسيق نوافذ الحوار في واجهة المستخدم (UI Dialog Coordination)، أو أنظمة التحكم في الحركة الجوية.",
    "mementoPros": "حفظ حالة الكائن دون انتهاك التغليف (Encapsulation)\nتبسيط كود الكائن الأصلي (Originator)",
    "mementoCons": "قد يستهلك الكثير من الذاكرة (RAM) إذا تم إنشاء Snapshots بشكل متكرر جداً",
    "mementoWhenToUse": "استخدمه عندما تريد حفظ صور (Snapshots) لحالة الكائن لتتمكن من استعادة حالته السابقة عند الحاجة.",
    "mementoBestUse": "أنظمة Undo/Redo، نقاط الحفظ في الألعاب (Game Checkpoints)، أو استعادة الإعدادات السابقة (Configuration Rollbacks).",
    "templateMethodPros": "السماح للمستخدمين بتخصيص أجزاء محددة فقط من خوارزمية كبيرة\nسحب الكود المكرر إلى الكلاس الأب",
    "templateMethodCons": "بعض المستخدمين قد يشعرون بالتقييد بسبب الهيكل المحدد للخوارزمية",
    "templateMethodWhenToUse": "استخدمه عندما تريد السماح للمستخدمين بتوسيع خطوات محددة فقط من الخوارزمية، وليس الخوارزمية بأكملها أو هيكلها العام.",
    "templateMethodBestUse": "أطر عمل معالجة البيانات (Data Processing Frameworks)، سكربتات البناء (Build Scripts)، أو نقاط التخصيص في الخوارزميات القياسية.",
    "visitorPros": "مبدأ المفتوح/المغلق\nمبدأ المسؤولية الواحدة\nيمكن للـ Visitor جمع معلومات مفيدة أثناء العمل مع كائنات مختلفة",
    "visitorCons": "تحتاج لتحديث جميع الـ Visitors في كل مرة يتم إضافة أو حذف كلاس من التسلسل الهرمي",
    "visitorWhenToUse": "استخدمه عندما تحتاج لتنفيذ عملية على جميع عناصر هيكل كائن معقد (مثل شجرة كائنات).",
    "visitorBestUse": "تصدير المستندات بصيغ مختلفة، أدوات تحليل الكود (Code Analysis/AST Visitors)، أو العمليات على مجموعات غير متجانسة.",
    "flyweightPros": "توفير كبير في استهلاك الذاكرة (RAM) إذا كان لديك عدد ضخم من الكائنات المتشابهة\nتحسين الأداء العام في الأنظمة التي تعاني من ضيق الذاكرة",
    "flyweightCons": "قد تضحي بالذاكرة مقابل استهلاك أكبر للمعالج (CPU) عند إعادة حساب بعض البيانات\nيصبح الكود أكثر تعقيداً بشكل ملحوظ",
    "flyweightWhenToUse": "استخدمه فقط عندما يجب أن يدعم برنامجك عدداً هائلاً من الكائنات التي بالكاد تتسع لها الذاكرة المتوفرة.",
    "flyweightBestUse": "أنظمة الجسيمات في الألعاب (Particle Systems مثل الدخان والنار)، علامات الخرائط في مجموعات البيانات الضخمة، أو محررات النصوص التي تتعامل مع ملايين الأحرف."
}