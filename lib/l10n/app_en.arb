{
    "@@locale": "en",
    "appTitle": "OOP Mastery",
    "home": "Home",
    "designPatterns": "Design Patterns",
    "refactoring": "Refactoring",
    "interviewQuestions": "Interview Questions",
    "darkMode": "Dark Mode",
    "lightMode": "Light Mode",
    "language": "Language",
    "creationalPatterns": "Creational Patterns",
    "creationalPatternsDesc": "Creational patterns abstract the instantiation process. They help make a system independent of how its objects are created, composed, and represented.",
    "factoryMethod": "Factory Method",
    "factoryMethodDesc": "Provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.",
    "abstractFactory": "Abstract Factory",
    "abstractFactoryDesc": "Lets you produce families of related objects without specifying their concrete classes.",
    "builder": "Builder",
    "builderDesc": "Lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.",
    "prototype": "Prototype",
    "prototypeDesc": "Lets you copy existing objects without making your code dependent on their classes.",
    "singleton": "Singleton",
    "singletonDesc": "Ensures that a class has only one instance, while providing a global access point to this instance.",
    "structuralPatterns": "Structural Patterns",
    "structuralPatternsDesc": "These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.",
    "adapter": "Adapter",
    "adapterDesc": "Allows objects with incompatible interfaces to collaborate.",
    "bridge": "Bridge",
    "bridgeDesc": "Lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.",
    "composite": "Composite",
    "compositeDesc": "Lets you compose objects into tree structures and then work with these structures as if they were individual objects.",
    "decorator": "Decorator",
    "decoratorDesc": "Lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.",
    "facade": "Facade",
    "facadeDesc": "Provides a simplified interface to a library, a framework, or any other complex set of classes.",
    "flyweight": "Flyweight",
    "flyweightDesc": "Lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.",
    "proxy": "Proxy",
    "proxyDesc": "Lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.",
    "behavioralPatterns": "Behavioral Patterns",
    "behavioralPatternsDesc": "Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.",
    "chainOfResponsibility": "Chain of Responsibility",
    "chainOfResponsibilityDesc": "Lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.",
    "command": "Command",
    "commandDesc": "Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request's execution, and support undoable operations.",
    "iterator": "Iterator",
    "iteratorDesc": "Lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).",
    "interpreter": "Interpreter",
    "interpreterDesc": "Given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.",
    "mediator": "Mediator",
    "mediatorDesc": "Lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.",
    "memento": "Memento",
    "mementoDesc": "Lets you save and restore the previous state of an object without revealing the details of its implementation.",
    "observer": "Observer",
    "observerDesc": "Lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they're observing.",
    "state": "State",
    "stateDesc": "Lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.",
    "strategy": "Strategy",
    "strategyDesc": "Lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.",
    "templateMethod": "Template Method",
    "templateMethodDesc": "Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.",
    "visitor": "Visitor",
    "visitorDesc": "Lets you separate algorithms from the objects on which they operate.",
    "refactoringCategories": "Refactoring Categories",
    "composingMethods": "Composing Methods",
    "composingMethodsDesc": "Much of refactoring is devoted to correctly composing methods. In most cases, excessively long methods are the root of all evil.",
    "movingFeatures": "Moving Features",
    "movingFeaturesDesc": "These techniques show how to safely move functionality between classes, create new classes, and hide implementation details.",
    "organizingData": "Organizing Data",
    "organizingDataDesc": "These techniques help with data handling, replacing primitives with rich class functionality.",
    "simplifyingConditionals": "Simplifying Conditionals",
    "simplifyingConditionalsDesc": "Conditionals have a tendency to become more complex in logic over time, and these techniques help combat that.",
    "simplifyingMethodCalls": "Simplifying Method Calls",
    "simplifyingMethodCallsDesc": "These techniques make method calls simpler and easier to understand.",
    "generalization": "Generalization",
    "generalizationDesc": "Generalization is primarily about moving functionality along the class inheritance hierarchy.",
    "notes": "Notes",
    "details": "Details",
    "example": "Dart Example",
    "goodExample": "Good Example",
    "badExample": "Bad Example",
    "seeMore": "See More",
    "reference": "Reference",
    "references": "References",
    "pros": "Pros",
    "cons": "Cons",
    "whenToUse": "When to Use",
    "bestUse": "Best Use Cases",
    "close": "Close",
    "extractMethod": "Extract Method",
    "inlineMethod": "Inline Method",
    "extractVariable": "Extract Variable",
    "moveMethod": "Move Method",
    "moveField": "Move Field",
    "extractClass": "Extract Class",
    "selfEncapsulateField": "Self Encapsulate Field",
    "replaceDataValueWithObject": "Replace Data Value with Object",
    "refactoringTip": "This technique helps simplify code structure and improve maintainability.",
    "copied": "Copied to clipboard!",
    "singletonNote": "Singletons should have a private constructor and a static instance accessor.",
    "factoryMethodNote": "Avoid 'if-else' ladders for object creation; use sub-classes to decide the concrete type.",
    "builderNote": "Builders solve the 'Telescoping Constructor' problem and provide readable code.",
    "singletonPros": "Controlled access to the sole instance.\nReduced name space (avoiding global variables).\nPermits refinement of operations and representation via subclassing.\nPermits a variable number of instances if logic changes.",
    "singletonCons": "Violates Single Responsibility Principle.\nCan mask bad design where components know too much about each other.\nRequires special handling in multi-threaded environments.\nDifficult to unit test due to global state.",
    "singletonWhenToUse": "Use when a class should have exactly one instance available to all clients (e.g., a database object or a file system manager).",
    "singletonBestUse": "Logging services, database connection pools, configuration managers, or hardware access.",
    "factoryMethodPros": "Avoids tight coupling between the creator and the concrete products.\nSingle Responsibility Principle: You can move the product creation code into one place.\nOpen/Closed Principle: You can introduce new product types without breaking client code.",
    "factoryMethodCons": "The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern.",
    "factoryMethodWhenToUse": "Use when you don't know beforehand the exact types and dependencies of the objects your code should work with.",
    "factoryMethodBestUse": "UI frameworks providing hooks for creating different components, or any system where the exact type is determined at runtime.",
    "abstractFactoryPros": "Guarantees compatibility of products.\nAvoids tight coupling.\nSingle Responsibility Principle.\nOpen/Closed Principle.",
    "abstractFactoryCons": "Code complexity increases with many new interfaces and classes.",
    "abstractFactoryWhenToUse": "Use when your code needs to work with various families of related products, but you don't want it to depend on the concrete classes of those products.",
    "abstractFactoryBestUse": "Cross-platform UI toolkits (Windows/Android/iOS styles), or multiple theme support.",
    "builderPros": "Construct objects step-by-step.\nReuse the same construction code for various representations.\nSingle Responsibility Principle (isolated complex construction).",
    "builderCons": "Increased overall complexity due to multiple new classes.",
    "builderWhenToUse": "Use to get rid of a 'telescoping constructor' (too many parameters) or when you need different representations of an object.",
    "builderBestUse": "Complex configurations, Document builders (HTML/JSON/PDF), or complex data models.",
    "prototypePros": "Clone objects without coupling to concrete classes.\nGet rid of repeated initialization code.\nProduce complex objects more conveniently.",
    "prototypeCons": "Cloning complex objects with circular references might be tricky.",
    "prototypeWhenToUse": "Use when the cost of creating a new object is higher than cloning an existing one.",
    "prototypeBestUse": "Game engines (spawning units), Graphics software, or Object caching.",
    "adapterPros": "Single Responsibility Principle (separable interface/data conversion).\nOpen/Closed Principle (new adapters without breaking client code).",
    "adapterCons": "Over-engineering (code complexity increases).",
    "adapterWhenToUse": "Use when you want to use an existing class, but its interface isn't compatible with the rest of your code.",
    "adapterBestUse": "Integrating 3rd party libraries, Legacy code migration, or XML/JSON data mapping.",
    "bridgePros": "Decouples abstraction from implementation.\nPlatform-independent code.\nOpen/Closed Principle.",
    "bridgeCons": "Might make code more complicated in highly cohesive classes.",
    "bridgeWhenToUse": "Use when you want to divide and organize a monolithic class that has several variants of some functionality.",
    "bridgeBestUse": "GUI frameworks, Cross-platform drivers, or Graphics libraries.",
    "compositePros": "Work with complex tree structures conveniently.\nOpen/Closed Principle.",
    "compositeCons": "Difficult to provide a common interface for classes whose functionality differs too much.",
    "compositeWhenToUse": "Use when you have to implement a tree-like object structure.",
    "compositeBestUse": "File systems, UI component hierarchies (widgets), or XML structures.",
    "decoratorPros": "Extend object's behavior without making a new subclass.\nAdd or remove responsibilities from an object at runtime.\nCombine several behaviors by wrapping an object into multiple decorators.",
    "decoratorCons": "Difficult to remove a specific wrapper from the wrappers stack.\nHard to implement a decorator in such a way that its behavior doesn't depend on the order in the decorators stack.",
    "decoratorWhenToUse": "Use when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.",
    "decoratorBestUse": "Streams (IO), Notification systems, or UI component wrappers (borders/scrollbars).",
    "facadePros": "Isolate your code from the complexity of a subsystem.",
    "facadeCons": "A facade can become a god object coupled to all classes of an app.",
    "facadeWhenToUse": "Use when you need to have a limited but straightforward interface to a complex subsystem.",
    "facadeBestUse": "Complex 3rd party SDKs, Audio/Video processing libraries, or Multi-service API clients.",
    "proxyPros": "Control the service object without clients knowing about it.\nManage life cycle of the service object.\nWorks even if the service object isn't ready or is not available.",
    "proxyCons": "The code may become more complicated since you need to introduce a lot of new classes.\nThe response from the service might be delayed.",
    "proxyWhenToUse": "Use for Lazy initialization (virtual proxy), Access control (protection proxy), or Logging requests (logging proxy).",
    "proxyBestUse": "Caching, Access Control, Lazy Loading, or Remote Service Proxy.",
    "observerPros": "Open/Closed Principle.\nEstablish relations between objects at runtime.",
    "observerCons": "Subscribers are notified in random order.",
    "observerWhenToUse": "Use when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.",
    "observerBestUse": "Event handling systems, UI updates in response to state changes (Streams/Notifiers), or Stock market trackers.",
    "strategyPros": "Swap algorithms used inside an object at runtime.\nIsolate implementation details of an algorithm from code that uses it.\nOpen/Closed Principle.",
    "strategyCons": "If you only have a couple of algorithms and they rarely change, no real reason to over-complicate the program with new classes.",
    "strategyWhenToUse": "Use when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.",
    "strategyBestUse": "Payment methods, Sorting algorithms, Route planning, or Compression styles.",
    "commandPros": "Single Responsibility Principle.\nOpen/Closed Principle.\nImplement undo/redo.\nImplement deferred execution.",
    "commandCons": "Code may become more complicated since you introduce a whole new layer between senders and receivers.",
    "commandWhenToUse": "Use when you want to parametrize objects with operations or queue/schedule their execution.",
    "commandBestUse": "GUI button actions, Undo/Redo systems, Task queues, or Transaction logs.",
    "statePros": "Single Responsibility Principle.\nOpen/Closed Principle.\nSimplify state-dependent code (eliminate massive switch/if-else).",
    "stateCons": "Applying the pattern can be overkill if a state machine has only a few states or rarely changes.",
    "stateWhenToUse": "Use when you have an object that behaves differently depending on its current state, the number of states is enormous, and the state-specific code changes frequently.",
    "stateBestUse": "Vending machines, Game character behaviors, Order processing, or Media players.",
    "chainOfResponsibilityPros": "You can control the order of request handling.\nSingle Responsibility Principle.\nOpen/Closed Principle.",
    "chainOfResponsibilityCons": "Some requests may end up unhandled.",
    "chainOfResponsibilityWhenToUse": "Use when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.",
    "chainOfResponsibilityBestUse": "Middleware in web frameworks, event bubbling in UI, or sequential validation logic.",
    "iteratorPros": "Single Responsibility Principle.\nOpen/Closed Principle.\nYou can delay an iteration and continue it when needed.",
    "iteratorCons": "Applying the pattern can be an overkill if your app only works with simple collections.",
    "iteratorWhenToUse": "Use when your collection has a complex data structure under the hood, but you want to hide its complexity from clients.",
    "iteratorBestUse": "Custom collection types, directory traversal, or complex data streaming.",
    "interpreterPros": "Easy to change and extend the grammar.\nImplementing the grammar is straightforward.",
    "interpreterCons": "Maintenance becomes difficult as the number of rules in the grammar increases.",
    "interpreterWhenToUse": "Use when you have a simple grammar to interpret and you can represent statements in the language as abstract syntax trees.",
    "interpreterBestUse": "SQL parsing, regular expressions, or mathematical expression evaluators.",
    "mediatorPros": "Single Responsibility Principle.\nOpen/Closed Principle.\nReduces coupling between various components of a program.",
    "mediatorCons": "Over time a mediator can evolve into a God Object.",
    "mediatorWhenToUse": "Use when it's hard to change some of the classes because they are tightly coupled to a bunch of other classes.",
    "mediatorBestUse": "Chat application rooms, UI dialog coordination, or airline traffic control systems.",
    "mementoPros": "You can produce snapshots of the object's state without violating its encapsulation.\nYou can simplify the originator's code.",
    "mementoCons": "The app might consume lots of RAM if clients create mementos too often.",
    "mementoWhenToUse": "Use when you want to produce snapshots of the object's state to be able to restore a previous state of the object.",
    "mementoBestUse": "Undo/Redo systems, game checkpoints, or configuration rollbacks.",
    "templateMethodPros": "You can let clients override only certain parts of a large algorithm.\nYou can pull the duplicate code into a superclass.",
    "templateMethodCons": "Some clients may be limited by the provided skeleton of an algorithm.",
    "templateMethodWhenToUse": "Use when you want to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure.",
    "templateMethodBestUse": "Data processing frameworks, build scripts, or standard algorithm hooks.",
    "visitorPros": "Open/Closed Principle.\nSingle Responsibility Principle.\nA visitor object can accumulate some useful information while working with various objects.",
    "visitorCons": "You need to update all visitors each time a class gets added to or removed from the element hierarchy.",
    "visitorWhenToUse": "Use when you need to perform an operation on all elements of a complex object structure (e.g., an object tree).",
    "visitorBestUse": "Document exporting, code analysis tools (AST visitors), or operations on heterogeneous collections.",
    "flyweightPros": "You can save lots of RAM, assuming your app has tons of similar objects.",
    "flyweightCons": "You might be exchanging RAM for CPU cycles when some of the context data needs to be recalculated.\nThe code becomes much more complicated.",
    "flyweightWhenToUse": "Use the Flyweight pattern only when your program must support a huge number of objects which barely fit into available RAM.",
    "flyweightBestUse": "Particle systems (smoke, fire), map markers in large datasets, or text editors handling millions of characters.",
    "answer": "Answer",
    "basicLevel": "Basic",
    "basicLevelDesc": "Fundamental concepts every Flutter developer should know.",
    "intermediateLevel": "Intermediate",
    "intermediateLevelDesc": "Deeper understanding of Flutter and Dart features.",
    "advancedLevel": "Advanced",
    "advancedLevelDesc": "Expert-level topics for senior developers.",
    "expertLevel": "Expert",
    "expertLevelDesc": "Expert-level topics for senior developers.",
    "qWhatIsFlutter": "What is Flutter?",
    "qWhatIsFlutterNotes": "Flutter is an open-source UI toolkit for building natively compiled applications for mobile, web, and desktop from a single codebase. It uses the Dart programming language and provides a rich set of customizable widgets and tools for fast development.",
    "qWhatIsFlutterPros": "High performance due to native compilation.\nHot reload for fast development.\nSingle codebase for multiple platforms.",
    "qWhatIsFlutterCons": "Larger app size compared to some alternatives.\nFewer third-party libraries.\nLearning Dart may be challenging for new developers.",
    "qWhatIsFlutterBestUse": "Ideal for building cross-platform mobile apps with beautiful custom UI and fast development cycles.",
    "qWhatIsDart": "What is Dart, and why is it used in Flutter?",
    "qWhatIsDartNotes": "Dart is a modern object-oriented programming language optimized for building UI, used to develop Flutter applications. It compiles to native code for high performance and has features like sound null-safety and a rich standard library.",
    "qWhatIsDartPros": "Easy to learn for developers familiar with C-style syntax.\nSupports both AOT and JIT compilation.\nStrong null-safety features.",
    "qWhatIsDartCons": "Smaller ecosystem compared to JavaScript.\nPrimarily used with Flutter, limiting server-side reuse.",
    "qWhatIsDartBestUse": "Best used for Flutter app development and client-side applications where performance and developer productivity matter.",
    "qWhatAreWidgets": "What are Widgets in Flutter?",
    "qWhatAreWidgetsNotes": "Widgets are the basic building blocks of a Flutter app's UI. Everything you see on screen in Flutter is a Widget, which can be either stateful or stateless. Widgets describe how to display elements on the screen in a declarative manner.",
    "qWhatAreWidgetsPros": "Highly customizable and composable.\nYou can build complex UIs by combining simpler widgets.\nFlutter's hot reload works well with its widget tree.",
    "qWhatAreWidgetsCons": "Deep widget hierarchies can become complex.\nRequires understanding of widget lifecycle for effective state management.",
    "qWhatAreWidgetsBestUse": "Use widgets for all UI components; take advantage of stateless widgets for static parts and stateful widgets for interactive parts.",
    "qStatelessVsStateful": "What is the difference between StatelessWidget and StatefulWidget?",
    "qStatelessVsStatefulNotes": "A StatelessWidget cannot change its state once built; it's immutable. A StatefulWidget has mutable state (via a State object) that can change over time, triggering rebuilds. StatelessWidget is simpler and more performant for static content. StatefulWidget allows dynamic and interactive UI.",
    "qStatelessVsStatefulPros": "StatelessWidget is simpler and more performant for static content.\nStatefulWidget allows dynamic and interactive UI.",
    "qStatelessVsStatefulCons": "StatelessWidget can't update UI based on changes.\nStatefulWidget introduces overhead of state management and rebuilds.",
    "qStatelessVsStatefulBestUse": "Use StatelessWidget for UI that doesn't change (e.g., static text), and StatefulWidget when UI needs to update (e.g., forms, animations).",
    "qWhatIsKey": "What is a Key in Flutter and why is it used?",
    "qWhatIsKeyNotes": "A Key is an identifier for Widgets, Elements, and SemanticsNodes. Keys preserve state and control widget identity when the widget tree changes (e.g., reordering). Using keys helps Flutter match widgets between builds.",
    "qWhatIsKeyPros": "Using keys (especially UniqueKey or ValueKey) helps avoid unexpected behavior when reordering or dynamically changing lists of widgets.",
    "qWhatIsKeyCons": "Often not needed unless you manage dynamic widget lists.\nOverusing keys can complicate the code.",
    "qWhatIsKeyBestUse": "Use keys when you have multiple widgets of the same type and need to preserve their state when they move or change position.",
    "qHotReloadVsRestart": "Explain the difference between Hot Reload and Hot Restart in Flutter.",
    "qHotReloadVsRestartNotes": "Hot Reload injects updated source code into a running Dart VM, preserving the app state and making UI changes visible almost instantly. Hot Restart completely restarts the app, rebuilding the widget tree and reinitializing state, which is slower than hot reload.",
    "qHotReloadVsRestartPros": "Hot Reload greatly speeds up UI development by preserving state.\nHot Restart ensures full reset, useful when major changes require clean state.",
    "qHotReloadVsRestartCons": "Hot Reload may not reflect changes outside widget code or initial setup.\nHot Restart is slower and loses the current state.",
    "qHotReloadVsRestartBestUse": "Use Hot Reload for quick iterations during UI development; use Hot Restart when you need to apply changes that require restarting the app.",
    "qMaterialAppScaffold": "What is the purpose of MaterialApp and Scaffold widgets?",
    "qMaterialAppScaffoldNotes": "MaterialApp is a convenience widget that wraps a number of widgets commonly required for Material Design applications, such as themes and navigation. Scaffold provides a framework for implementing the basic visual layout structure of Material Design (app bars, drawers, bottom sheets, etc.).",
    "qMaterialAppScaffoldPros": "MaterialApp handles app-level configurations (theme, locale, navigator).\nScaffold provides standard UI elements out of the box.",
    "qMaterialAppScaffoldCons": "They impose Material Design.\nFor a custom look or non-Material design, one might use WidgetsApp or a custom layout.",
    "qMaterialAppScaffoldBestUse": "Use MaterialApp and Scaffold when developing a Flutter app following Material Design guidelines.",
    "qWidgetLifecycle": "What is a Flutter Widget's lifecycle (StatefulWidget lifecycle)?",
    "qWidgetLifecycleNotes": "A StatefulWidget has a State object whose lifecycle includes initState(), didChangeDependencies(), build(), setState(), deactivate(), dispose(), and reassemble (during hot reload). initState is called once when the widget is inserted into the widget tree; build() is called often to redraw; dispose() is called when the widget is removed.",
    "qWidgetLifecyclePros": "Understanding lifecycle is crucial for resource management (e.g., initializing and disposing controllers) and for controlling rebuilds.",
    "qWidgetLifecycleCons": "Managing complex lifecycles can be error-prone.\nForgetting to dispose can cause memory leaks.",
    "qWidgetLifecycleBestUse": "Use initState for one-time initialization, build to construct the UI, and dispose to clean up resources like animations or streams.",
    "qWhatAreMixins": "What are mixins in Dart and how are they used?",
    "qWhatAreMixinsNotes": "Mixins allow a class to use methods and properties from multiple classes without multiple inheritance. In Dart, you define a mixin with the 'mixin' keyword and then use it with the 'with' keyword in a class declaration. They are useful for code reuse.",
    "qWhatAreMixinsPros": "Provide a way to add common functionality to multiple classes without forcing an inheritance relationship.\nThey keep classes more modular.",
    "qWhatAreMixinsCons": "Overusing mixins can lead to complex hierarchies and unexpected behavior if many mixins modify similar properties.",
    "qWhatAreMixinsBestUse": "Use mixins when you want to share functionality (like logging, validation, etc.) across different classes without creating a base class.",
    "qExtensionMethods": "What are extension methods in Dart?",
    "qExtensionMethodsNotes": "Extension methods allow you to add new methods (or getters/setters) to existing libraries or classes without modifying them. Defined using the 'extension' keyword, they are a syntactic convenience to extend functionality.",
    "qExtensionMethodsPros": "Enable cleaner code by extending functionality of built-in types or classes (e.g., adding utility methods to String).",
    "qExtensionMethodsCons": "They can make code harder to discover, as methods are not visible on the original class definition.",
    "qExtensionMethodsBestUse": "Use extension methods to add helper functions to types in your project without creating utility classes.",
    "qListsSetsMaps": "What are Lists, Sets, and Maps in Dart and when to use each?",
    "qListsSetsMapsNotes": "List is an ordered collection allowing duplicates; use when order matters. Set is an unordered collection of unique items; use when you need uniqueness. Map is a key-value store; use when you need to associate values with keys for fast lookup.",
    "qListsSetsMapsProsPros": "Lists allow indexed access and ordering.\nSets ensure no duplicates and provide fast membership checks.\nMaps provide fast key-based lookup.",
    "qListsSetsMapsProsCons": "Lists may be inefficient if you need to enforce uniqueness.\nSets do not maintain insertion order.\nMaps use more memory per entry than a simple list.",
    "qListsSetsMapsProsBestUse": "Use List for ordered data sequences, Set for unique collections, and Map for key-value associations.",
    "qSolidPrinciples": "What are the SOLID principles and how do they apply in Flutter?",
    "qSolidPrinciplesNotes": "SOLID refers to five principles of object-oriented design: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. In Flutter, keep widgets/controllers with a single responsibility, use abstractions for dependencies, and make classes open for extension but closed for modification.",
    "qSolidPrinciplesPros": "Following SOLID makes code more maintainable, testable, and extensible.\nFor Flutter, it encourages clean separation of UI and logic.",
    "qSolidPrinciplesCons": "Strict adherence can lead to more abstraction and boilerplate.\nIt may complicate simple projects if overdone.",
    "qSolidPrinciplesBestUse": "Use SOLID to structure larger Flutter apps; start simple but refactor towards SOLID as complexity grows.",
    "qBlocPattern": "What is the BLoC pattern in Flutter?",
    "qBlocPatternNotes": "BLoC (Business Logic Component) is an architectural pattern that separates business logic from UI by using Streams. BLoC exposes streams of data, and UI widgets listen to them. This makes the code more testable and reusable.",
    "qBlocPatternPros": "Promotes separation of concerns and testability.\nWorks well with reactive programming.\nSimplifies state management for complex apps.",
    "qBlocPatternCons": "Adds boilerplate (stream controllers, sinks, etc.).\nCan be overkill for simple apps.\nLearning curve is higher than simple setState.",
    "qBlocPatternBestUse": "Use BLoC for medium to large apps where separation of logic is beneficial. For smaller apps, simpler methods may suffice.",
    "qProviderVsBloc": "What is Provider in Flutter and how does it differ from BLoC?",
    "qProviderVsBlocNotes": "Provider is a wrapper around InheritedWidget that makes state management easier by providing and accessing state objects. Unlike BLoC (which uses Streams), Provider often uses ChangeNotifier or simple objects. Provider simplifies passing data down the widget tree.",
    "qProviderVsBlocPros": "Lightweight and easy to use.\nLess boilerplate than BLoC.\nWell-integrated with Flutter.",
    "qProviderVsBlocCons": "Does not enforce a strict pattern, which can lead to scattered state logic if not organized.\nLess formal separation than BLoC.",
    "qProviderVsBlocBestUse": "Use Provider for simpler state management needs or smaller apps. It integrates well with Flutter and is easier to start with than BLoC.",
    "qFutureVsStream": "What is the difference between Future and Stream in Dart?",
    "qFutureVsStreamNotes": "A Future represents a single asynchronous computation that either completes with a value or an error. A Stream represents a sequence of asynchronous events or data over time. FutureBuilder is used for one-time async results, StreamBuilder for ongoing data streams.",
    "qFutureVsStreamPros": "Use Future for single HTTP requests or quick async tasks.\nUse Stream for events like WebSocket messages, sensor data, or periodic updates.",
    "qFutureVsStreamCons": "Future cannot handle multiple values or continuous updates.\nStreams introduce more complexity (listeners, cancellations).",
    "qFutureVsStreamBestUse": "Use Future when expecting a single result. Use Stream when listening for multiple results or changes over time.",
    "qNavigationPushReplace": "How do you navigate between screens in Flutter? (push, pushReplacement)",
    "qNavigationPushReplaceNotes": "Navigation in Flutter uses the Navigator widget. Navigator.push adds a route to the stack (user can press back to return). Navigator.pushReplacement replaces the current route with a new one, removing the previous from the stack.",
    "qNavigationPushReplacePros": "push keeps the previous screen in memory (user can go back).\npushReplacement removes it (suitable for login screens or flows where going back is not needed).",
    "qNavigationPushReplaceCons": "push can accumulate many routes if not managed (memory).\npushReplacement prevents back navigation but loses previous screen state.",
    "qNavigationPushReplaceBestUse": "Use push for normal forward navigation. Use pushReplacement for replacing screens permanently (e.g., after login or splash screen).",
    "qNavigator1Vs2": "What is the difference between Navigator 1.0 and Navigator 2.0?",
    "qNavigator1Vs2Notes": "Navigator 1.0 is the classic imperative API (push/pop by widget), while Navigator 2.0 is a declarative, URL-based API with Router and RouteInformationParser. Navigator 2.0 offers more control over browser URL and deep linking.",
    "qNavigator1Vs2Pros": "Navigator 2.0 enables web and more complex navigation patterns (deep linking).",
    "qNavigator1Vs2Cons": "Navigator 2.0 has a steeper learning curve and more code overhead.\nFor simple apps, Navigator 1.0 is easier to use.",
    "qNavigator1Vs2BestUse": "Use Navigator 2.0 for web apps or apps requiring deep linking and custom routing behavior. For basic navigation, 1.0 is sufficient.",
    "qBuildContext": "What is Flutter's build() method context parameter?",
    "qBuildContextNotes": "BuildContext is an object which represents the location of a widget in the widget tree. It is passed to the build method and can be used to access theme data, localization, and to find ancestor widgets in the tree.",
    "qBuildContextPros": "Allows widgets to access inherited widgets like Theme or MediaQuery.\nEssential for widget communication.",
    "qBuildContextCons": "Misusing context (e.g., using it before initState or in async) can lead to errors.",
    "qBuildContextBestUse": "Use context inside build() to obtain theme or other inherited data, or Navigator for navigation.",
    "qWhatIsIsolate": "What is an Isolate in Dart and how is it used?",
    "qWhatIsIsolateNotes": "An Isolate is a separate thread of execution that doesn't share memory with the main isolate. It has its own memory heap. Communication is done via message passing (SendPort/ReceivePort). Use isolates for CPU-intensive tasks to avoid blocking the main UI thread.",
    "qWhatIsIsolatePros": "Enables true parallel computation in Dart without shared-memory concurrency bugs.\nImproves performance for heavy tasks.",
    "qWhatIsIsolateCons": "Communication via message passing can be complex and slower.\nStarting an isolate has overhead; not suitable for small tasks.",
    "qWhatIsIsolateBestUse": "Use isolates for expensive computations (image processing, large computations) off the main thread. For most UI tasks, use async/await instead.",
    "qFutureBuilderStreamBuilder": "What are FutureBuilder and StreamBuilder used for in Flutter?",
    "qFutureBuilderStreamBuilderNotes": "FutureBuilder is a widget that builds itself based on the latest snapshot of interaction with a Future. StreamBuilder similarly rebuilds when new Stream events arrive. They simplify handling of asynchronous data in the UI without manual listeners.",
    "qFutureBuilderStreamBuilderPros": "Makes it easy to update UI based on async results or stream data.\nHandles connection states and snapshots automatically.",
    "qFutureBuilderStreamBuilderCons": "Can lead to rebuilds on every event.\nNeed to manage performance if streams are frequent.",
    "qFutureBuilderStreamBuilderBestUse": "Use FutureBuilder for one-time async calls (like HTTP requests) and StreamBuilder for continuous data (like realtime updates or web sockets).",
    "qConstructorFactory": "What is a Constructor in Dart and what are factory constructors?",
    "qConstructorFactoryNotes": "A constructor in Dart is a special method to create objects of a class. A factory constructor is a special type of constructor that can return an existing instance or a subclass. It's declared with the 'factory' keyword. Useful for singleton or cache implementations.",
    "qConstructorFactoryPros": "Factory constructors allow control over instance creation (e.g., implementing singletons or caches).\nCan return different subtypes.",
    "qConstructorFactoryCons": "Factory constructors cannot access 'this' and don't automatically create a new instance.\nThey add complexity compared to a normal constructor.",
    "qConstructorFactoryBestUse": "Use factory constructors for patterns like singleton or when you need custom logic to decide which instance to return.",
    "qSingletonPattern": "What is a Singleton pattern and how can you implement it in Dart?",
    "qSingletonPatternNotes": "Singleton ensures a class has only one instance and provides a global access point. In Dart, you can implement a singleton by using a private constructor and a static instance. Useful for caches or shared resources.",
    "qSingletonPatternPros": "Ensures a single shared instance across the app (useful for caches, shared resources).",
    "qSingletonPatternCons": "Global state can make testing harder and lead to hidden dependencies.",
    "qSingletonPatternBestUse": "Use singleton for classes that manage global state or resources (e.g., a settings manager or network client).",
    "qFlutterPerformance": "How do you optimize Flutter application performance?",
    "qFlutterPerformanceNotes": "Common Flutter performance optimizations include: using const constructors to avoid rebuilds, splitting widgets to reduce rebuild scope, using efficient data structures, minimizing widget layers (RepaintBoundary), and caching images or data. Avoid large asset sizes and excessive rebuilds.",
    "qFlutterPerformancePros": "Applying these techniques can significantly improve frame rates and responsiveness.",
    "qFlutterPerformanceCons": "Over-optimizing early can complicate code.\nFocus on bottlenecks identified by profiling.",
    "qFlutterPerformanceBestUse": "Use performance profiling (DevTools) to find bottlenecks. Apply optimizations like const constructors, efficient layout, and offloading work to isolates as needed.",
    "qRenderingEngine": "What is Flutter's rendering engine and how does it work (e.g., Skia, Impeller)?",
    "qRenderingEngineNotes": "Flutter's default rendering engine is Skia, a C++ based 2D graphics library. The newer Impeller engine improves performance and reduces graphical issues on some platforms. These engines compile Flutter's UI to native graphics commands on each platform.",
    "qRenderingEnginePros": "Skia provides high-quality, fast rendering.\nImpeller further optimizes GPU use and predictability.",
    "qRenderingEngineCons": "Engine details are mostly abstracted away.\nDevelopers should be aware for debugging only.\nImpeller is still maturing on some platforms.",
    "qRenderingEngineBestUse": "Benefit from engine improvements via Flutter upgrades. For advanced needs (e.g., custom shaders), learn how to use the appropriate engine.",
    "qFlutterVsReactNative": "Compare Flutter with React Native: what are the pros and cons?",
    "qFlutterVsReactNativeNotes": "Flutter and React Native are both cross-platform frameworks. Flutter compiles to native ARM code and has its own rendering, offering high performance. React Native uses a JavaScript bridge to native components, which can be slower. Flutter's UI is highly customizable, while React Native uses native widgets with less flexibility.",
    "qFlutterVsReactNativePros": "Flutter: high performance, full UI control, one codebase.\nReact Native: larger library ecosystem, JavaScript familiarity for web developers.",
    "qFlutterVsReactNativeCons": "Flutter: larger app size, Dart is less known, fewer third-party packages.\nReact Native: performance overhead from JS bridge, UI consistency issues.",
    "qFlutterVsReactNativeBestUse": "Use Flutter when performance and custom UI are top priorities. Use React Native if leveraging existing JavaScript code or ecosystem matters more.",
    "qInheritanceVsComposition": "Explain inheritance and composition in Dart.",
    "qInheritanceVsCompositionNotes": "Inheritance is when a class extends another class, inheriting its properties and methods (\"is-a\" relationship). Composition is when a class includes instances of other classes as fields (\"has-a\" relationship). Composition is often preferred for flexibility.",
    "qInheritanceVsCompositionPros": "Inheritance makes code reuse easy for closely related classes.\nComposition provides more flexibility and looser coupling.",
    "qInheritanceVsCompositionCons": "Inheritance can lead to rigid hierarchies and tight coupling.\nComposition can lead to more boilerplate but is more adaptable.",
    "qInheritanceVsCompositionBestUse": "Use inheritance when classes have clear hierarchy and share behavior. Use composition to assemble behavior from multiple classes for flexibility.",
    "qWhatIsPolymorphism": "What is polymorphism in object-oriented programming?",
    "qWhatIsPolymorphismNotes": "Polymorphism means \"many forms\". In Dart, it allows treating objects of different classes through a common interface (e.g., methods overridden in subclasses). A function can accept a base class type and operate on any subclass instance.",
    "qWhatIsPolymorphismPros": "Makes code more flexible and reusable by programming to an interface or superclass rather than concrete classes.",
    "qWhatIsPolymorphismCons": "May make code harder to understand if overused, as the actual object type is less obvious.",
    "qWhatIsPolymorphismBestUse": "Use polymorphism when you want to use a common interface (abstract class or base class) for different concrete implementations.",
    "search": "Search questions...",
    "noResults": "No results found",
    "all": "All",
    "answr": "Answer",
    "codeExample": "Code Example",
    "programmingTerms": "Programming Terms",
    "usefulPubPackages": "Useful Pub Packages",
    "tags": "Tags",
    "theoretical": "Theoretical",
    "practical": "Practical",
    "cBasic": "Basic",
    "cSecurity": "Security",
    "cOOP": "OOP",
    "cSolid": "SOLID",
    "cDesignPatterns": "Design Patterns",
    "cDataStructures": "Data Structures",
    "cStateManagement": "State Management",
    "cPerformance": "Performance",
    "cTesting": "Testing",
    "cNetworking": "Networking",
    "cDatabase": "Database",
    "cArchitecture": "Architecture",
    "cDartBasics": "Dart Basics",
    "cFlutterBasics": "Flutter Basics",
    "cUI": "UI",
    "cNativePlatform": "Native Platform",
    "cAnimations": "Animations",
    "cModernFeatures": "Modern Features",
    "cDeployment": "Deployment",
    "questionNotFound": "Question not found",
    "onlyBookmarked": "Only Bookmarked",
    "allLevels": "All Levels",
    "commonMistakes": "Common Mistakes",
    "noPattern": "No pattern",

  "pGoF": "Classic (GoF)",
  "pNonGoF": "Non-GoF",
  "pPractical": "Practical",
  "pModern": "Modern",
  "designPattern": "Design Patterns",
  "architecturalPattern": "Architectural Patterns",
  "stateManagementPattern": "State Management Patterns",
  "uiPattern": "UI Patterns",
  "projectStructurePattern": "Project Structure Patterns",
  "creationalPattern": "Creational Patterns",
  "structuralPattern": "Structural Patterns",
  "behavioralPattern": "Behavioral Patterns",

  "relatedPatterns": "Related Patterns",
  "oftenConfusedWith": "Often Confused With"
}