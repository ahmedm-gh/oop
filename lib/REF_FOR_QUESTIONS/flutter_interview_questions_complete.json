{
  "metadata": {
    "version": "1.0.0",
    "lastUpdated": "2026-02-07",
    "flutterVersion": "3.27+",
    "dartVersion": "3.6+",
    "totalQuestions": 30,
    "languages": [
      "en",
      "ar"
    ],
    "description": {
      "en": "Comprehensive Flutter interview questions covering basic to expert level topics",
      "ar": "أسئلة مقابلة Flutter شاملة تغطي المواضيع من المستوى الأساسي إلى الخبير"
    }
  },
  "questions": [
    {
      "id": "FLT-001",
      "difficulty": "basic",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "widgets",
        "dartBasics"
      ],
      "content": {
        "en": {
          "question": "What is Flutter and how does it differ from other mobile development frameworks?",
          "answer": "Flutter is Google's open-source UI toolkit for building natively compiled applications for mobile, web, and desktop from a single codebase. Key differences: 1) Uses Dart programming language, 2) Provides its own rendering engine (Skia/Impeller), 3) Widgets are not wrappers around native components, 4) Hot reload for faster development, 5) Single codebase for multiple platforms, 6) Direct compilation to native ARM code for better performance.",
          "notes": "Flutter's rendering approach gives consistent UI across platforms but requires downloading the rendering engine with the app.",
          "bestUse": "Cross-platform apps requiring consistent UI/UX, high-performance apps, apps with complex custom UI"
        },
        "ar": {
          "question": "ما هو Flutter وكيف يختلف عن أطر تطوير التطبيقات المحمولة الأخرى؟",
          "answer": "Flutter هو مجموعة أدوات واجهة المستخدم مفتوحة المصدر من Google لبناء تطبيقات مترجمة محليًا للهاتف المحمول والويب وسطح المكتب من قاعدة كود واحدة. الاختلافات الرئيسية: 1) يستخدم لغة البرمجة Dart، 2) يوفر محرك العرض الخاص به (Skia/Impeller)، 3) الويدجتات ليست أغلفة حول المكونات الأصلية، 4) إعادة التحميل السريع لتطوير أسرع، 5) قاعدة كود واحدة لمنصات متعددة، 6) التجميع المباشر إلى كود ARM الأصلي لأداء أفضل.",
          "notes": "نهج العرض في Flutter يوفر واجهة مستخدم متسقة عبر المنصات ولكنه يتطلب تنزيل محرك العرض مع التطبيق.",
          "bestUse": "التطبيقات متعددة المنصات التي تتطلب واجهة مستخدم/تجربة مستخدم متسقة، التطبيقات عالية الأداء، التطبيقات ذات واجهة المستخدم المخصصة المعقدة"
        }
      },
      "pros": [
        "Fast development with hot reload",
        "Single codebase for multiple platforms",
        "Excellent performance",
        "Rich widget library",
        "Strong community support"
      ],
      "cons": [
        "Larger app size due to engine inclusion",
        "Relatively newer compared to native development",
        "Limited third-party libraries compared to native"
      ]
    },
    {
      "id": "FLT-002",
      "difficulty": "basic",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "widgets",
        "statelessWidget",
        "statefulWidget"
      ],
      "content": {
        "en": {
          "question": "What is the difference between StatelessWidget and StatefulWidget?",
          "answer": "StatelessWidget: Immutable widget that doesn't maintain any state. It's built once and doesn't rebuild unless its parent rebuilds. Use for static content. StatefulWidget: Mutable widget that maintains state. It can rebuild itself when setState() is called or when dependencies change. Has a State object that persists between rebuilds. Use when widget needs to change based on user interaction or data changes.",
          "example": "class MyText extends StatelessWidget { /* static */ }\nclass Counter extends StatefulWidget { /* has state */ }",
          "notes": "Choose StatelessWidget by default for better performance; only use StatefulWidget when state is needed.",
          "bestUse": "StatelessWidget for displaying static data; StatefulWidget for interactive UI, forms, animations"
        },
        "ar": {
          "question": "ما الفرق بين StatelessWidget و StatefulWidget؟",
          "answer": "StatelessWidget: ويدجت غير قابل للتغيير لا يحتفظ بأي حالة. يتم بناؤه مرة واحدة ولا يعاد بناؤه إلا إذا أعاد الأصل بناءه. استخدمه للمحتوى الثابت. StatefulWidget: ويدجت قابل للتغيير يحتفظ بالحالة. يمكنه إعادة بناء نفسه عند استدعاء ()setState أو عند تغيير التبعيات. له كائن State يستمر بين عمليات إعادة البناء. استخدمه عندما يحتاج الويدجت إلى التغيير بناءً على تفاعل المستخدم أو تغييرات البيانات.",
          "example": "class MyText extends StatelessWidget { /* ثابت */ }\nclass Counter extends StatefulWidget { /* له حالة */ }",
          "notes": "اختر StatelessWidget افتراضيًا لأداء أفضل؛ استخدم StatefulWidget فقط عندما تكون الحالة مطلوبة.",
          "bestUse": "StatelessWidget لعرض البيانات الثابتة؛ StatefulWidget لواجهة المستخدم التفاعلية والنماذج والرسوم المتحركة"
        }
      },
      "pros": [
        "StatelessWidget: Better performance, simpler",
        "StatefulWidget: Dynamic content, user interaction support"
      ],
      "cons": [
        "StatelessWidget: Cannot handle dynamic changes",
        "StatefulWidget: More complex, potential performance overhead if misused"
      ]
    },
    {
      "id": "FLT-003",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "buildContext",
        "widgets"
      ],
      "content": {
        "en": {
          "question": "What is BuildContext and why is it important?",
          "answer": "BuildContext is a handle to the location of a widget in the widget tree. It represents the relationship between a widget and its ancestors. Important for: 1) Accessing inherited widgets (Theme.of(context)), 2) Navigation, 3) Showing dialogs/snackbars, 4) MediaQuery for screen dimensions, 5) Finding ancestor/descendant widgets. Each widget has its own BuildContext passed to the build() method.",
          "example": "Theme.of(context).primaryColor\nNavigator.of(context).push(...)\nMediaQuery.of(context).size",
          "notes": "Context is only valid during the build phase; don't store it for later async use without proper handling.",
          "bestUse": "Accessing theme data, navigation, inherited widgets, responsive design"
        },
        "ar": {
          "question": "ما هو BuildContext ولماذا هو مهم؟",
          "answer": "BuildContext هو مؤشر لموقع الويدجت في شجرة الويدجت. يمثل العلاقة بين الويدجت وأسلافه. مهم لـ: 1) الوصول إلى الويدجتات الموروثة (Theme.of(context))، 2) التنقل، 3) عرض الحوارات/الإشعارات، 4) MediaQuery لأبعاد الشاشة، 5) العثور على الويدجتات الأسلاف/الأحفاد. كل ويدجت له BuildContext الخاص به يتم تمريره إلى طريقة ()build.",
          "example": "Theme.of(context).primaryColor\nNavigator.of(context).push(...)\nMediaQuery.of(context).size",
          "notes": "السياق صالح فقط أثناء مرحلة البناء؛ لا تخزنه للاستخدام غير المتزامن اللاحق بدون معالجة مناسبة.",
          "bestUse": "الوصول إلى بيانات السمة، التنقل، الويدجتات الموروثة، التصميم المستجيب"
        }
      }
    },
    {
      "id": "FLT-004",
      "difficulty": "basic",
      "category": "oop",
      "type": "theoretical",
      "tags": [
        "dartBasics",
        "encapsulation",
        "inheritance",
        "polymorphism",
        "abstraction"
      ],
      "content": {
        "en": {
          "question": "Explain the four pillars of Object-Oriented Programming with Dart examples.",
          "answer": "1) Encapsulation: Bundling data and methods, hiding internal details using private members (underscore prefix). 2) Inheritance: Creating new classes from existing ones using 'extends'. 3) Polymorphism: Objects taking multiple forms through method overriding and interfaces. 4) Abstraction: Hiding complex implementation details using abstract classes and interfaces.",
          "example": "// Encapsulation\nclass Account { String _balance; }\n// Inheritance\nclass SavingsAccount extends Account {}\n// Polymorphism\n@override void deposit() {}\n// Abstraction\nabstract class Shape { void draw(); }",
          "notes": "Dart supports single inheritance but multiple interface implementation. Use mixins for shared behavior.",
          "bestUse": "Encapsulation for data protection, inheritance for code reuse, polymorphism for flexibility, abstraction for clean APIs"
        },
        "ar": {
          "question": "اشرح الأعمدة الأربعة للبرمجة كائنية التوجه مع أمثلة Dart.",
          "answer": "1) التغليف: تجميع البيانات والطرق، إخفاء التفاصيل الداخلية باستخدام الأعضاء الخاصة (بادئة الشرطة السفلية). 2) الوراثة: إنشاء فئات جديدة من الفئات الموجودة باستخدام 'extends'. 3) تعدد الأشكال: الكائنات تتخذ أشكالًا متعددة من خلال تجاوز الطرق والواجهات. 4) التجريد: إخفاء تفاصيل التنفيذ المعقدة باستخدام الفئات والواجهات المجردة.",
          "example": "// التغليف\nclass Account { String _balance; }\n// الوراثة\nclass SavingsAccount extends Account {}\n// تعدد الأشكال\n@override void deposit() {}\n// التجريد\nabstract class Shape { void draw(); }",
          "notes": "Dart يدعم الوراثة الفردية ولكن تنفيذ واجهات متعددة. استخدم mixins للسلوك المشترك.",
          "bestUse": "التغليف لحماية البيانات، الوراثة لإعادة استخدام الكود، تعدد الأشكال للمرونة، التجريد لواجهات برمجية نظيفة"
        }
      }
    },
    {
      "id": "FLT-005",
      "difficulty": "intermediate",
      "category": "solid",
      "type": "theoretical",
      "tags": [
        "singleResponsibility",
        "openClosed",
        "liskovSubstitution",
        "interfaceSegregation",
        "dependencyInversion"
      ],
      "content": {
        "en": {
          "question": "Explain all five SOLID principles with Flutter/Dart examples.",
          "answer": "S - Single Responsibility: A class should have one reason to change. Example: Separate UserRepository from UserValidator. O - Open/Closed: Open for extension, closed for modification. Use abstract classes/interfaces. L - Liskov Substitution: Subclasses should be substitutable for their base classes without breaking functionality. I - Interface Segregation: Don't force classes to implement interfaces they don't use. Create specific interfaces. D - Dependency Inversion: Depend on abstractions, not concretions. Use dependency injection.",
          "example": "// SRP\nclass UserRepository { /* only data access */ }\nclass UserValidator { /* only validation */ }\n// DIP\nclass UserService {\n  final IUserRepository repository;\n  UserService(this.repository); // inject abstraction\n}",
          "notes": "SOLID principles improve code maintainability, testability, and scalability. Essential for large Flutter applications.",
          "bestUse": "Apply in service layers, repositories, and business logic. Essential for clean architecture."
        },
        "ar": {
          "question": "اشرح جميع مبادئ SOLID الخمسة مع أمثلة Flutter/Dart.",
          "answer": "S - المسؤولية الواحدة: يجب أن يكون للفئة سبب واحد للتغيير. مثال: فصل UserRepository عن UserValidator. O - المفتوح/المغلق: مفتوح للتوسع، مغلق للتعديل. استخدم الفئات/الواجهات المجردة. L - استبدال ليسكوف: يجب أن تكون الفئات الفرعية قابلة للاستبدال بفئاتها الأساسية دون كسر الوظائف. I - فصل الواجهة: لا تجبر الفئات على تنفيذ واجهات لا تستخدمها. أنشئ واجهات محددة. D - عكس التبعية: اعتمد على التجريدات، وليس على التفاصيل الملموسة. استخدم حقن التبعية.",
          "example": "// SRP\nclass UserRepository { /* الوصول للبيانات فقط */ }\nclass UserValidator { /* التحقق فقط */ }\n// DIP\nclass UserService {\n  final IUserRepository repository;\n  UserService(this.repository); // حقن التجريد\n}",
          "notes": "مبادئ SOLID تحسن قابلية الصيانة والاختبار وقابلية التوسع للكود. ضرورية للتطبيقات الكبيرة في Flutter.",
          "bestUse": "طبقها في طبقات الخدمة والمستودعات ومنطق الأعمال. ضرورية للبنية النظيفة."
        }
      }
    },
    {
      "id": "FLT-006",
      "difficulty": "intermediate",
      "category": "designPatterns",
      "type": "practical",
      "tags": [
        "singleton",
        "factory",
        "repository"
      ],
      "content": {
        "en": {
          "question": "Implement Singleton, Factory, and Repository patterns in Flutter.",
          "answer": "Singleton: Ensures only one instance exists. Use for app-wide services. Factory: Creates objects without exposing creation logic. Use factory constructors in Dart. Repository: Abstracts data sources, provides clean API for data access.",
          "example": "// Singleton\nclass ApiService {\n  static final ApiService _instance = ApiService._internal();\n  factory ApiService() => _instance;\n  ApiService._internal();\n}\n\n// Factory\nclass Animal {\n  factory Animal.fromType(String type) {\n    if (type == 'dog') return Dog();\n    return Cat();\n  }\n}\n\n// Repository\nabstract class IUserRepository {\n  Future<User> getUser(String id);\n}\nclass UserRepository implements IUserRepository {\n  final ApiService _api;\n  final LocalDatabase _db;\n  Future<User> getUser(String id) async {\n    try { return await _api.getUser(id); }\n    catch (_) { return await _db.getUser(id); }\n  }\n}",
          "notes": "Singleton can cause testing issues; consider using dependency injection instead. Repository pattern is crucial for testable code.",
          "bestUse": "Singleton for global services, Factory for object creation, Repository for data layer abstraction"
        },
        "ar": {
          "question": "نفذ أنماط Singleton و Factory و Repository في Flutter.",
          "answer": "Singleton: يضمن وجود نسخة واحدة فقط. استخدمه للخدمات على مستوى التطبيق. Factory: ينشئ كائنات دون كشف منطق الإنشاء. استخدم منشئات factory في Dart. Repository: يجرد مصادر البيانات، يوفر واجهة برمجية نظيفة للوصول إلى البيانات.",
          "example": "// Singleton\nclass ApiService {\n  static final ApiService _instance = ApiService._internal();\n  factory ApiService() => _instance;\n  ApiService._internal();\n}\n\n// Factory\nclass Animal {\n  factory Animal.fromType(String type) {\n    if (type == 'dog') return Dog();\n    return Cat();\n  }\n}\n\n// Repository\nabstract class IUserRepository {\n  Future<User> getUser(String id);\n}\nclass UserRepository implements IUserRepository {\n  final ApiService _api;\n  final LocalDatabase _db;\n  Future<User> getUser(String id) async {\n    try { return await _api.getUser(id); }\n    catch (_) { return await _db.getUser(id); }\n  }\n}",
          "notes": "Singleton يمكن أن يسبب مشاكل في الاختبار؛ فكر في استخدام حقن التبعية بدلاً من ذلك. نمط Repository حاسم للكود القابل للاختبار.",
          "bestUse": "Singleton للخدمات العامة، Factory لإنشاء الكائنات، Repository لتجريد طبقة البيانات"
        }
      },
      "pros": [
        "Singleton: Global access point, memory efficient",
        "Factory: Flexible object creation, encapsulation",
        "Repository: Testable, separates concerns, switch data sources easily"
      ],
      "cons": [
        "Singleton: Hard to test, global state issues",
        "Factory: Can become complex",
        "Repository: Additional abstraction layer"
      ]
    },
    {
      "id": "FLT-007",
      "difficulty": "basic",
      "category": "dataStructures",
      "type": "theoretical",
      "tags": [
        "dartBasics",
        "algorithms"
      ],
      "content": {
        "en": {
          "question": "What are the main data structures available in Dart and when to use each?",
          "answer": "List: Ordered collection, indexed access, allows duplicates. Use for ordered data. Set: Unordered collection, unique elements only. Use when uniqueness matters. Map: Key-value pairs, fast lookup by key. Use for associative data. Queue: FIFO operations. LinkedHashSet: Maintains insertion order. HashMap/LinkedHashMap: Different iteration guarantees.",
          "example": "List<String> items = ['a', 'b', 'c'];\nSet<int> uniqueIds = {1, 2, 3};\nMap<String, User> userMap = {'id1': user1};\nQueue<Task> taskQueue = Queue();",
          "notes": "Choose based on requirements: order, uniqueness, lookup speed. List for most cases, Set for uniqueness, Map for key-based access.",
          "bestUse": "List for ordered collections, Set for unique items, Map for fast key lookups, Queue for task scheduling"
        },
        "ar": {
          "question": "ما هي هياكل البيانات الرئيسية المتاحة في Dart ومتى تستخدم كل منها؟",
          "answer": "List: مجموعة مرتبة، وصول مفهرس، تسمح بالتكرار. استخدمها للبيانات المرتبة. Set: مجموعة غير مرتبة، عناصر فريدة فقط. استخدمها عندما يهم التفرد. Map: أزواج مفتاح-قيمة، بحث سريع بالمفتاح. استخدمها للبيانات الترابطية. Queue: عمليات FIFO. LinkedHashSet: يحافظ على ترتيب الإدراج. HashMap/LinkedHashMap: ضمانات تكرار مختلفة.",
          "example": "List<String> items = ['a', 'b', 'c'];\nSet<int> uniqueIds = {1, 2, 3};\nMap<String, User> userMap = {'id1': user1};\nQueue<Task> taskQueue = Queue();",
          "notes": "اختر بناءً على المتطلبات: الترتيب، التفرد، سرعة البحث. List لمعظم الحالات، Set للتفرد، Map للوصول القائم على المفتاح.",
          "bestUse": "List للمجموعات المرتبة، Set للعناصر الفريدة، Map للبحث السريع بالمفاتيح، Queue لجدولة المهام"
        }
      }
    },
    {
      "id": "FLT-008",
      "difficulty": "intermediate",
      "category": "stateManagement",
      "type": "practical",
      "tags": [
        "provider",
        "bloc",
        "riverpod",
        "setState"
      ],
      "content": {
        "en": {
          "question": "Compare setState, Provider, BLoC, and Riverpod for state management.",
          "answer": "setState: Built-in, simple, local state only, causes entire widget rebuild. Provider: InheritedWidget wrapper, easy to use, dependency injection, less boilerplate than BLoC. BLoC: Stream-based, separates business logic from UI, more boilerplate, great for complex apps. Riverpod: Provider 2.0, compile-time safety, no BuildContext needed, better testing, modern approach.",
          "example": "// setState\nsetState(() { counter++; });\n\n// Provider\nProvider.of<Counter>(context).increment();\n\n// BLoC\ncounterBloc.add(IncrementEvent());\n\n// Riverpod\nref.read(counterProvider.notifier).increment();",
          "notes": "Choose based on app complexity: setState for simple, Provider for medium, BLoC for complex enterprise, Riverpod for modern type-safe approach.",
          "bestUse": "setState for local state, Provider for simple global state, BLoC for complex business logic, Riverpod for new projects wanting type safety"
        },
        "ar": {
          "question": "قارن بين setState و Provider و BLoC و Riverpod لإدارة الحالة.",
          "answer": "setState: مدمج، بسيط، حالة محلية فقط، يسبب إعادة بناء الويدجت بالكامل. Provider: غلاف InheritedWidget، سهل الاستخدام، حقن التبعية، أقل كودًا نمطيًا من BLoC. BLoC: قائم على التدفقات، يفصل منطق الأعمال عن واجهة المستخدم، المزيد من الكود النمطي، رائع للتطبيقات المعقدة. Riverpod: Provider 2.0، أمان وقت الترجمة، لا حاجة لـ BuildContext، اختبار أفضل، نهج حديث.",
          "example": "// setState\nsetState(() { counter++; });\n\n// Provider\nProvider.of<Counter>(context).increment();\n\n// BLoC\ncounterBloc.add(IncrementEvent());\n\n// Riverpod\nref.read(counterProvider.notifier).increment();",
          "notes": "اختر بناءً على تعقيد التطبيق: setState للبسيط، Provider للمتوسط، BLoC للمعقد، Riverpod للنهج الحديث الآمن من حيث النوع.",
          "bestUse": "setState للحالة المحلية، Provider للحالة العامة البسيطة، BLoC لمنطق الأعمال المعقد، Riverpod للمشاريع الجديدة التي تريد أمان النوع"
        }
      },
      "pros": [
        "setState: Simple, no dependencies",
        "Provider: Easy learning curve, good community",
        "BLoC: Testable, scalable, clear separation",
        "Riverpod: Type-safe, no context, excellent testing"
      ],
      "cons": [
        "setState: Doesn't scale, hard to manage",
        "Provider: Can get verbose, runtime errors",
        "BLoC: Steep learning curve, more code",
        "Riverpod: Newer, smaller ecosystem"
      ]
    },
    {
      "id": "FLT-009",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "practical",
      "tags": [
        "asyncAwait",
        "futures",
        "streams"
      ],
      "content": {
        "en": {
          "question": "Explain Future, async/await, and Streams in Dart with examples.",
          "answer": "Future: Represents a potential value or error available at some time in the future. Single asynchronous result. async/await: Syntactic sugar for working with Futures, makes async code look synchronous. Streams: Sequence of asynchronous events, can emit multiple values over time. Single vs multiple subscription streams.",
          "example": "// Future\nFuture<String> fetchData() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Data';\n}\n\n// async/await\nvoid loadData() async {\n  final data = await fetchData();\n  print(data);\n}\n\n// Stream\nStream<int> countStream() async* {\n  for (int i = 0; i < 5; i++) {\n    await Future.delayed(Duration(seconds: 1));\n    yield i;\n  }\n}\n\n// Listen to stream\ncountStream().listen((value) => print(value));",
          "notes": "Use Future for single async operations (API calls), Streams for continuous data (WebSocket, user events). Always handle errors with try-catch or catchError.",
          "bestUse": "Future for HTTP requests, database queries; Streams for real-time data, event handling, user input"
        },
        "ar": {
          "question": "اشرح Future و async/await و Streams في Dart مع أمثلة.",
          "answer": "Future: يمثل قيمة محتملة أو خطأ متاح في وقت ما في المستقبل. نتيجة غير متزامنة واحدة. async/await: سكر نحوي للعمل مع Futures، يجعل الكود غير المتزامن يبدو متزامنًا. Streams: تسلسل من الأحداث غير المتزامنة، يمكن أن يصدر قيمًا متعددة مع مرور الوقت. تدفقات اشتراك واحد مقابل اشتراك متعدد.",
          "example": "// Future\nFuture<String> fetchData() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Data';\n}\n\n// async/await\nvoid loadData() async {\n  final data = await fetchData();\n  print(data);\n}\n\n// Stream\nStream<int> countStream() async* {\n  for (int i = 0; i < 5; i++) {\n    await Future.delayed(Duration(seconds: 1));\n    yield i;\n  }\n}\n\n// الاستماع للتدفق\ncountStream().listen((value) => print(value));",
          "notes": "استخدم Future للعمليات غير المتزامنة الواحدة (استدعاءات API)، Streams للبيانات المستمرة (WebSocket، أحداث المستخدم). تعامل دائمًا مع الأخطاء باستخدام try-catch أو catchError.",
          "bestUse": "Future لطلبات HTTP واستعلامات قاعدة البيانات؛ Streams للبيانات في الوقت الفعلي ومعالجة الأحداث وإدخال المستخدم"
        }
      }
    },
    {
      "id": "FLT-010",
      "difficulty": "advanced",
      "category": "performance",
      "type": "practical",
      "tags": [
        "optimization",
        "lazyLoading",
        "memoryManagement"
      ],
      "content": {
        "en": {
          "question": "What are the best practices for optimizing Flutter app performance?",
          "answer": "1) Use const constructors for immutable widgets. 2) Implement ListView.builder for long lists (lazy loading). 3) Avoid unnecessary rebuilds with keys, const, RepaintBoundary. 4) Use cached_network_image for images. 5) Minimize expensive operations in build(). 6) Profile with Flutter DevTools. 7) Use compute() for heavy computations. 8) Implement pagination. 9) Optimize images (size, format). 10) Use Impeller rendering engine (Flutter 3.10+).",
          "example": "// Const constructor\nconst Text('Static text');\n\n// ListView.builder\nListView.builder(\n  itemCount: items.length,\n  itemBuilder: (context, index) => ItemWidget(items[index]),\n);\n\n// Isolate for heavy work\nawait compute(heavyComputation, data);\n\n// RepaintBoundary\nRepaintBoundary(\n  child: ComplexWidget(),\n);",
          "notes": "Profile before optimizing. Use Flutter DevTools to identify bottlenecks. Premature optimization can harm code readability.",
          "bestUse": "Apply these techniques in production apps with performance issues, especially with large lists or complex UI"
        },
        "ar": {
          "question": "ما هي أفضل الممارسات لتحسين أداء تطبيق Flutter؟",
          "answer": "1) استخدم منشئات const للويدجتات غير القابلة للتغيير. 2) نفذ ListView.builder للقوائم الطويلة (التحميل الكسول). 3) تجنب عمليات إعادة البناء غير الضرورية باستخدام المفاتيح و const و RepaintBoundary. 4) استخدم cached_network_image للصور. 5) قلل العمليات المكلفة في ()build. 6) راقب الأداء باستخدام Flutter DevTools. 7) استخدم ()compute للحسابات الثقيلة. 8) نفذ الترقيم. 9) حسّن الصور (الحجم والتنسيق). 10) استخدم محرك العرض Impeller (Flutter 3.10+).",
          "example": "// منشئ Const\nconst Text('نص ثابت');\n\n// ListView.builder\nListView.builder(\n  itemCount: items.length,\n  itemBuilder: (context, index) => ItemWidget(items[index]),\n);\n\n// Isolate للعمل الثقيل\nawait compute(heavyComputation, data);\n\n// RepaintBoundary\nRepaintBoundary(\n  child: ComplexWidget(),\n);",
          "notes": "راقب الأداء قبل التحسين. استخدم Flutter DevTools لتحديد الاختناقات. التحسين المبكر يمكن أن يضر بقابلية قراءة الكود.",
          "bestUse": "طبق هذه التقنيات في تطبيقات الإنتاج مع مشاكل الأداء، خاصة مع القوائم الكبيرة أو واجهة المستخدم المعقدة"
        }
      }
    },
    {
      "id": "FLT-011",
      "difficulty": "basic",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "keys"
      ],
      "content": {
        "en": {
          "question": "What are Keys in Flutter and when should you use them?",
          "answer": "Keys are identifiers for widgets, elements, and semantic nodes. They help Flutter identify which widgets have changed, been added, or removed. Types: ValueKey (uses a value), ObjectKey (uses an object), UniqueKey (always unique), GlobalKey (access widget state across tree). Use when: reordering lists, preserving state during parent rebuild, accessing widget state from outside.",
          "example": "// ValueKey for list items\nListView(\n  children: items.map((item) => \n    ListTile(key: ValueKey(item.id), ...)\n  ).toList(),\n);\n\n// GlobalKey to access state\nfinal GlobalKey<FormState> _formKey = GlobalKey();\n_formKey.currentState?.validate();",
          "notes": "Don't overuse keys. Only use when Flutter's default element reconciliation isn't sufficient. GlobalKeys are expensive.",
          "bestUse": "Reorderable lists, form validation, preserving scroll position, AnimatedList"
        },
        "ar": {
          "question": "ما هي المفاتيح (Keys) في Flutter ومتى يجب استخدامها؟",
          "answer": "المفاتيح هي معرّفات للويدجتات والعناصر والعقد الدلالية. تساعد Flutter في تحديد الويدجتات التي تغيرت أو أضيفت أو أزيلت. الأنواع: ValueKey (يستخدم قيمة)، ObjectKey (يستخدم كائنًا)، UniqueKey (فريد دائمًا)، GlobalKey (الوصول لحالة الويدجت عبر الشجرة). الاستخدام: إعادة ترتيب القوائم، الحفاظ على الحالة أثناء إعادة بناء الأصل، الوصول لحالة الويدجت من الخارج.",
          "example": "// ValueKey لعناصر القائمة\nListView(\n  children: items.map((item) => \n    ListTile(key: ValueKey(item.id), ...)\n  ).toList(),\n);\n\n// GlobalKey للوصول للحالة\nfinal GlobalKey<FormState> _formKey = GlobalKey();\n_formKey.currentState?.validate();",
          "notes": "لا تفرط في استخدام المفاتيح. استخدمها فقط عندما لا تكون مطابقة عنصر Flutter الافتراضية كافية. GlobalKeys مكلفة.",
          "bestUse": "القوائم القابلة لإعادة الترتيب، التحقق من صحة النماذج، الحفاظ على موضع التمرير، AnimatedList"
        }
      }
    },
    {
      "id": "FLT-012",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "lifecycle"
      ],
      "content": {
        "en": {
          "question": "Explain the StatefulWidget lifecycle methods and when each is called.",
          "answer": "1) createState(): Called when widget is inserted into tree, creates State object. 2) initState(): Called once when State is created, initialize data, subscriptions. 3) didChangeDependencies(): Called after initState and when dependencies change. 4) build(): Called every time widget needs to be rendered. 5) didUpdateWidget(): Called when widget configuration changes. 6) setState(): Triggers rebuild. 7) deactivate(): Called when State is removed from tree temporarily. 8) dispose(): Called when State is removed permanently, cleanup resources.",
          "example": "@override\nvoid initState() {\n  super.initState();\n  _controller = AnimationController(...);\n}\n\n@override\nvoid dispose() {\n  _controller.dispose();\n  super.dispose();\n}",
          "notes": "Always call super.initState() and super.dispose(). Clean up in dispose() to prevent memory leaks. Don't call setState() in dispose().",
          "bestUse": "initState for initialization, dispose for cleanup, didUpdateWidget for responding to parent changes"
        },
        "ar": {
          "question": "اشرح طرق دورة حياة StatefulWidget ومتى يتم استدعاء كل منها.",
          "answer": "1) createState(): يُستدعى عند إدراج الويدجت في الشجرة، ينشئ كائن State. 2) initState(): يُستدعى مرة واحدة عند إنشاء State، تهيئة البيانات والاشتراكات. 3) didChangeDependencies(): يُستدعى بعد initState وعندما تتغير التبعيات. 4) build(): يُستدعى في كل مرة يحتاج فيها الويدجت للعرض. 5) didUpdateWidget(): يُستدعى عند تغيير تكوين الويدجت. 6) setState(): يؤدي إلى إعادة البناء. 7) deactivate(): يُستدعى عند إزالة State من الشجرة مؤقتًا. 8) dispose(): يُستدعى عند إزالة State بشكل دائم، تنظيف الموارد.",
          "example": "@override\nvoid initState() {\n  super.initState();\n  _controller = AnimationController(...);\n}\n\n@override\nvoid dispose() {\n  _controller.dispose();\n  super.dispose();\n}",
          "notes": "دائمًا استدع super.initState() و super.dispose(). نظف في dispose() لمنع تسريبات الذاكرة. لا تستدع setState() في dispose().",
          "bestUse": "initState للتهيئة، dispose للتنظيف، didUpdateWidget للاستجابة لتغييرات الأصل"
        }
      }
    },
    {
      "id": "FLT-013",
      "difficulty": "intermediate",
      "category": "testing",
      "type": "practical",
      "tags": [
        "unitTesting",
        "widgetTesting",
        "mockito"
      ],
      "content": {
        "en": {
          "question": "Explain different types of testing in Flutter and provide examples.",
          "answer": "1) Unit Tests: Test individual functions/classes in isolation. Fast, no UI. 2) Widget Tests: Test UI components, widget tree. Medium speed. 3) Integration Tests: Test complete app flows. Slow, most realistic. Use mockito for mocking dependencies. Test directory structure: test/ for unit/widget tests, integration_test/ for integration tests.",
          "example": "// Unit Test\ntest('Counter increments', () {\n  final counter = Counter();\n  counter.increment();\n  expect(counter.value, 1);\n});\n\n// Widget Test\ntestWidgets('Finds text', (tester) async {\n  await tester.pumpWidget(MyApp());\n  expect(find.text('Hello'), findsOneWidget);\n});\n\n// Mock with Mockito\nclass MockApiService extends Mock implements ApiService {}\n\ntest('Repository test', () async {\n  final mockApi = MockApiService();\n  when(mockApi.fetchUser()).thenAnswer((_) async => User());\n});",
          "notes": "Aim for 80%+ code coverage. Test business logic thoroughly. Widget tests for UI. Mock external dependencies.",
          "bestUse": "Unit tests for logic, widget tests for UI behavior, integration tests for critical user flows"
        },
        "ar": {
          "question": "اشرح أنواع الاختبار المختلفة في Flutter وقدم أمثلة.",
          "answer": "1) اختبارات الوحدة: اختبار الوظائف/الفئات الفردية بشكل منعزل. سريعة، بدون واجهة مستخدم. 2) اختبارات الويدجت: اختبار مكونات واجهة المستخدم وشجرة الويدجت. سرعة متوسطة. 3) اختبارات التكامل: اختبار تدفقات التطبيق الكاملة. بطيئة، الأكثر واقعية. استخدم mockito لإنشاء التبعيات الوهمية. هيكل دليل الاختبار: test/ لاختبارات الوحدة/الويدجت، integration_test/ لاختبارات التكامل.",
          "example": "// اختبار الوحدة\ntest('Counter increments', () {\n  final counter = Counter();\n  counter.increment();\n  expect(counter.value, 1);\n});\n\n// اختبار الويدجت\ntestWidgets('Finds text', (tester) async {\n  await tester.pumpWidget(MyApp());\n  expect(find.text('مرحبا'), findsOneWidget);\n});\n\n// Mock مع Mockito\nclass MockApiService extends Mock implements ApiService {}\n\ntest('Repository test', () async {\n  final mockApi = MockApiService();\n  when(mockApi.fetchUser()).thenAnswer((_) async => User());\n});",
          "notes": "استهدف تغطية كود 80%+. اختبر منطق الأعمال بشكل شامل. اختبارات الويدجت لواجهة المستخدم. أنشئ نماذج وهمية للتبعيات الخارجية.",
          "bestUse": "اختبارات الوحدة للمنطق، اختبارات الويدجت لسلوك واجهة المستخدم، اختبارات التكامل لتدفقات المستخدم الحرجة"
        }
      }
    },
    {
      "id": "FLT-014",
      "difficulty": "advanced",
      "category": "modernFeatures",
      "type": "theoretical",
      "tags": [
        "impellerEngine",
        "material3",
        "fragmentShaders"
      ],
      "content": {
        "en": {
          "question": "What is Impeller rendering engine and how does it improve Flutter?",
          "answer": "Impeller is Flutter's next-generation rendering engine (stable since Flutter 3.10 on iOS, 3.16 on Android). Replaces Skia. Key improvements: 1) Precompiled shaders eliminate runtime compilation jank. 2) Predictable performance, no shader compilation stutters. 3) Modern graphics APIs (Metal on iOS, Vulkan on Android). 4) Better text rendering. 5) Improved memory usage. 6) Foundation for advanced features like fragment shaders.",
          "example": "// Enabled by default on iOS (3.10+) and Android (3.16+)\n// To explicitly enable in flutter run:\nflutter run --enable-impeller\n\n// Fragment Shader example (Flutter 3.7+)\nui.FragmentProgram.fromAsset('shaders/myshader.frag').then((program) {\n  final shader = program.fragmentShader();\n  // Use shader with CustomPainter\n});",
          "notes": "Impeller is default on iOS (3.10+) and Android (3.16+). Significant performance improvement, especially for complex animations. Some edge cases may still use Skia as fallback.",
          "bestUse": "All Flutter apps on modern versions benefit automatically. Particularly important for animation-heavy apps."
        },
        "ar": {
          "question": "ما هو محرك العرض Impeller وكيف يحسن Flutter؟",
          "answer": "Impeller هو محرك العرض من الجيل التالي لـ Flutter (مستقر منذ Flutter 3.10 على iOS، 3.16 على Android). يحل محل Skia. التحسينات الرئيسية: 1) المظللات المجمعة مسبقًا تقضي على التجميع في وقت التشغيل. 2) أداء يمكن التنبؤ به، لا توقفات في تجميع المظللات. 3) واجهات رسومات حديثة (Metal على iOS، Vulkan على Android). 4) عرض نص أفضل. 5) تحسين استخدام الذاكرة. 6) أساس للميزات المتقدمة مثل مظللات الشظايا.",
          "example": "// مفعل افتراضيًا على iOS (3.10+) و Android (3.16+)\n// للتفعيل الصريح في flutter run:\nflutter run --enable-impeller\n\n// مثال Fragment Shader (Flutter 3.7+)\nui.FragmentProgram.fromAsset('shaders/myshader.frag').then((program) {\n  final shader = program.fragmentShader();\n  // استخدم shader مع CustomPainter\n});",
          "notes": "Impeller هو الافتراضي على iOS (3.10+) و Android (3.16+). تحسين أداء كبير، خاصة للرسوم المتحركة المعقدة. بعض الحالات الحدية قد تستخدم Skia كبديل احتياطي.",
          "bestUse": "جميع تطبيقات Flutter على الإصدارات الحديثة تستفيد تلقائيًا. مهم بشكل خاص للتطبيقات ذات الرسوم المتحركة المكثفة."
        }
      }
    },
    {
      "id": "FLT-015",
      "difficulty": "intermediate",
      "category": "networking",
      "type": "practical",
      "tags": [
        "http",
        "dio",
        "restApi"
      ],
      "content": {
        "en": {
          "question": "Compare http package vs dio for API calls. When to use each?",
          "answer": "http: Official Dart package, simple, lightweight, minimal features. Good for basic API calls. dio: Third-party, feature-rich, interceptors, file upload/download with progress, request cancellation, timeout, retry logic, FormData, better error handling. Choose http for simple apps, dio for production apps needing advanced features.",
          "example": "// http package\nimport 'package:http/http.dart' as http;\nfinal response = await http.get(Uri.parse('https://api.example.com/data'));\n\n// dio package\nimport 'package:dio/dio.dart';\nfinal dio = Dio();\ndio.interceptors.add(InterceptorsWrapper(\n  onRequest: (options, handler) {\n    options.headers['Authorization'] = 'Bearer token';\n    return handler.next(options);\n  },\n));\nfinal response = await dio.get('https://api.example.com/data');",
          "notes": "Dio provides better developer experience for complex apps. http is sufficient for simple use cases. Both support json encoding/decoding.",
          "bestUse": "http for simple REST calls, dio for apps needing interceptors, file uploads, better error handling"
        },
        "ar": {
          "question": "قارن بين حزمة http و dio لاستدعاءات API. متى تستخدم كل منها؟",
          "answer": "http: حزمة Dart الرسمية، بسيطة، خفيفة الوزن، ميزات قليلة. جيدة لاستدعاءات API الأساسية. dio: من طرف ثالث، غنية بالميزات، محاعترضات، رفع/تنزيل الملفات مع التقدم، إلغاء الطلبات، المهلة، منطق إعادة المحاولة، FormData، معالجة أخطاء أفضل. اختر http للتطبيقات البسيطة، dio لتطبيقات الإنتاج التي تحتاج ميزات متقدمة.",
          "example": "// حزمة http\nimport 'package:http/http.dart' as http;\nfinal response = await http.get(Uri.parse('https://api.example.com/data'));\n\n// حزمة dio\nimport 'package:dio/dio.dart';\nfinal dio = Dio();\ndio.interceptors.add(InterceptorsWrapper(\n  onRequest: (options, handler) {\n    options.headers['Authorization'] = 'Bearer token';\n    return handler.next(options);\n  },\n));\nfinal response = await dio.get('https://api.example.com/data');",
          "notes": "Dio توفر تجربة مطور أفضل للتطبيقات المعقدة. http كافية للحالات البسيطة. كلاهما يدعم ترميز/فك ترميز json.",
          "bestUse": "http لاستدعاءات REST البسيطة، dio للتطبيقات التي تحتاج محاعترضات ورفع ملفات ومعالجة أخطاء أفضل"
        }
      }
    },
    {
      "id": "FLT-016",
      "difficulty": "intermediate",
      "category": "database",
      "type": "practical",
      "tags": [
        "sqflite",
        "hive",
        "isar",
        "sharedPreferences"
      ],
      "content": {
        "en": {
          "question": "Compare local storage solutions: SharedPreferences, Hive, Sqflite, and Isar.",
          "answer": "SharedPreferences: Key-value pairs, simple data, primitives only, slow for large data. Hive: NoSQL, fast, type-safe with adapters, no native SQL, good for medium data. Sqflite: SQLite wrapper, relational database, complex queries, larger learning curve. Isar: Modern NoSQL, fastest, type-safe, queries, indexes, multi-isolate, zero-config.",
          "example": "// SharedPreferences\nfinal prefs = await SharedPreferences.getInstance();\nawait prefs.setString('key', 'value');\n\n// Hive\nawait Hive.initFlutter();\nfinal box = await Hive.openBox('myBox');\nbox.put('key', 'value');\n\n// Sqflite\nfinal db = await openDatabase('my.db');\nawait db.insert('users', {'name': 'John'});\n\n// Isar\nfinal isar = await Isar.open([UserSchema]);\nawait isar.writeTxn(() => isar.users.put(user));",
          "notes": "Choose based on data complexity: SharedPreferences for settings, Hive for objects, Sqflite for relational data, Isar for modern high-performance apps.",
          "bestUse": "SharedPreferences: app settings; Hive: cached objects; Sqflite: complex relational data; Isar: modern apps needing speed"
        },
        "ar": {
          "question": "قارن بين حلول التخزين المحلي: SharedPreferences و Hive و Sqflite و Isar.",
          "answer": "SharedPreferences: أزواج مفتاح-قيمة، بيانات بسيطة، أنواع بدائية فقط، بطيء للبيانات الكبيرة. Hive: NoSQL، سريع، آمن من حيث النوع مع المحولات، لا SQL أصلي، جيد للبيانات المتوسطة. Sqflite: غلاف SQLite، قاعدة بيانات علائقية، استعلامات معقدة، منحنى تعلم أكبر. Isar: NoSQL حديث، الأسرع، آمن من حيث النوع، استعلامات، فهارس، عزل متعدد، بدون تكوين.",
          "example": "// SharedPreferences\nfinal prefs = await SharedPreferences.getInstance();\nawait prefs.setString('key', 'value');\n\n// Hive\nawait Hive.initFlutter();\nfinal box = await Hive.openBox('myBox');\nbox.put('key', 'value');\n\n// Sqflite\nfinal db = await openDatabase('my.db');\nawait db.insert('users', {'name': 'John'});\n\n// Isar\nfinal isar = await Isar.open([UserSchema]);\nawait isar.writeTxn(() => isar.users.put(user));",
          "notes": "اختر بناءً على تعقيد البيانات: SharedPreferences للإعدادات، Hive للكائنات، Sqflite للبيانات العلائقية، Isar للتطبيقات الحديثة عالية الأداء.",
          "bestUse": "SharedPreferences: إعدادات التطبيق؛ Hive: الكائنات المخزنة مؤقتًا؛ Sqflite: البيانات العلائقية المعقدة؛ Isar: التطبيقات الحديثة التي تحتاج السرعة"
        }
      }
    },
    {
      "id": "FLT-017",
      "difficulty": "advanced",
      "category": "architecture",
      "type": "practical",
      "tags": [
        "cleanArchitecture",
        "mvvm",
        "repository"
      ],
      "content": {
        "en": {
          "question": "Explain Clean Architecture in Flutter with layers and folder structure.",
          "answer": "Clean Architecture separates concerns into layers: 1) Presentation (UI, widgets, state management), 2) Domain (business logic, use cases, entities), 3) Data (repositories, data sources, models). Dependency rule: outer layers depend on inner, not vice versa. Folder structure: lib/features/[feature]/presentation|domain|data. Benefits: testable, maintainable, scalable, independent of frameworks.",
          "example": "lib/\n├── core/\n│   ├── error/\n│   ├── usecases/\n│   └── utils/\n└── features/\n    └── authentication/\n        ├── data/\n        │   ├── datasources/\n        │   │   └── auth_remote_datasource.dart\n        │   ├── models/\n        │   └── repositories/\n        │       └── auth_repository_impl.dart\n        ├── domain/\n        │   ├── entities/\n        │   │   └── user.dart\n        │   ├── repositories/\n        │   │   └── auth_repository.dart\n        │   └── usecases/\n        │       └── login_user.dart\n        └── presentation/\n            ├── bloc/\n            ├── pages/\n            └── widgets/",
          "notes": "Clean Architecture increases initial complexity but pays off in large applications. Use for enterprise apps, not simple projects.",
          "bestUse": "Large-scale applications, enterprise projects, teams needing clear separation of concerns"
        },
        "ar": {
          "question": "اشرح البنية النظيفة (Clean Architecture) في Flutter مع الطبقات وهيكل المجلدات.",
          "answer": "البنية النظيفة تفصل الاهتمامات إلى طبقات: 1) العرض (واجهة المستخدم، الويدجتات، إدارة الحالة)، 2) النطاق (منطق الأعمال، حالات الاستخدام، الكيانات)، 3) البيانات (المستودعات، مصادر البيانات، النماذج). قاعدة التبعية: الطبقات الخارجية تعتمد على الداخلية، وليس العكس. هيكل المجلدات: lib/features/[feature]/presentation|domain|data. الفوائد: قابل للاختبار، قابل للصيانة، قابل للتوسع، مستقل عن الأطر.",
          "example": "lib/\n├── core/\n│   ├── error/\n│   ├── usecases/\n│   └── utils/\n└── features/\n    └── authentication/\n        ├── data/\n        │   ├── datasources/\n        │   │   └── auth_remote_datasource.dart\n        │   ├── models/\n        │   └── repositories/\n        │       └── auth_repository_impl.dart\n        ├── domain/\n        │   ├── entities/\n        │   │   └── user.dart\n        │   ├── repositories/\n        │   │   └── auth_repository.dart\n        │   └── usecases/\n        │       └── login_user.dart\n        └── presentation/\n            ├── bloc/\n            ├── pages/\n            └── widgets/",
          "notes": "البنية النظيفة تزيد التعقيد الأولي لكنها تؤتي ثمارها في التطبيقات الكبيرة. استخدمها للتطبيقات المؤسسية، وليس المشاريع البسيطة.",
          "bestUse": "التطبيقات واسعة النطاق، المشاريع المؤسسية، الفرق التي تحتاج فصلًا واضحًا للاهتمامات"
        }
      }
    },
    {
      "id": "FLT-018",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "nullSafety"
      ],
      "content": {
        "en": {
          "question": "Explain Dart null safety and its operators.",
          "answer": "Null safety prevents null reference errors at compile time. Types are non-nullable by default. Operators: ? (nullable type), ! (null assertion, runtime error if null), ?? (null-aware operator, default value), ??= (assign if null), ?. (null-aware access), ...? (null-aware spread), late (lazy initialization). Benefits: fewer bugs, better performance, clearer APIs.",
          "example": "String? nullable; // Can be null\nString nonNull = 'value'; // Cannot be null\n\nprint(nullable?.length); // Safe access\nprint(nullable ?? 'default'); // Default value\nprint(nullable!.length); // Force unwrap, throws if null\n\nlate String lateInit; // Initialize later\nlateInit = 'value';",
          "notes": "Null safety is mandatory since Dart 2.12. Use ! sparingly, prefer ?. and ??. Use late for expensive initialization or circular dependencies.",
          "bestUse": "All Dart code. Null safety eliminates entire class of runtime errors."
        },
        "ar": {
          "question": "اشرح أمان القيمة الفارغة (null safety) في Dart ومعاملاته.",
          "answer": "أمان القيمة الفارغة يمنع أخطاء المرجع الفارغ في وقت الترجمة. الأنواع غير قابلة للقيمة الفارغة افتراضيًا. المعاملات: ? (نوع قابل للقيمة الفارغة)، ! (تأكيد القيمة الفارغة، خطأ في وقت التشغيل إذا كانت فارغة)، ?? (معامل واعي بالقيمة الفارغة، قيمة افتراضية)، ??= (تعيين إذا كانت فارغة)، ?. (وصول واعي بالقيمة الفارغة)، ...? (انتشار واعي بالقيمة الفارغة)، late (تهيئة كسولة). الفوائد: أخطاء أقل، أداء أفضل، واجهات برمجية أوضح.",
          "example": "String? nullable; // يمكن أن تكون فارغة\nString nonNull = 'value'; // لا يمكن أن تكون فارغة\n\nprint(nullable?.length); // وصول آمن\nprint(nullable ?? 'افتراضي'); // قيمة افتراضية\nprint(nullable!.length); // فرض فك التغليف، يرمي إذا كانت فارغة\n\nlate String lateInit; // تهيئة لاحقة\nlateInit = 'value';",
          "notes": "أمان القيمة الفارغة إلزامي منذ Dart 2.12. استخدم ! بحذر، فضّل ?. و ??. استخدم late للتهيئة المكلفة أو التبعيات الدائرية.",
          "bestUse": "جميع أكواد Dart. أمان القيمة الفارغة يزيل فئة كاملة من أخطاء وقت التشغيل."
        }
      }
    },
    {
      "id": "FLT-019",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "practical",
      "tags": [
        "isolates",
        "asyncAwait"
      ],
      "content": {
        "en": {
          "question": "What are Isolates in Dart and when should you use them?",
          "answer": "Isolates are independent workers with their own memory heap. Dart is single-threaded but uses isolates for true parallelism. Unlike threads, isolates don't share memory, communicate via message passing. Use for: heavy computations (parsing large JSON, image processing, encryption), avoiding UI jank. Use compute() function for simple cases, or manually create isolates for complex scenarios.",
          "example": "// Using compute() helper\nimport 'package:flutter/foundation.dart';\n\nFuture<List<Photo>> parsePhotos(String responseBody) async {\n  return compute(parsePhotosInIsolate, responseBody);\n}\n\nList<Photo> parsePhotosInIsolate(String responseBody) {\n  final parsed = jsonDecode(responseBody).cast<Map<String, dynamic>>();\n  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();\n}\n\n// Manual isolate\nimport 'dart:isolate';\n\nvoid heavyTask(SendPort sendPort) {\n  // Perform computation\n  sendPort.send(result);\n}\n\nfinal receivePort = ReceivePort();\nawait Isolate.spawn(heavyTask, receivePort.sendPort);\nfinal result = await receivePort.first;",
          "notes": "Isolates have overhead (memory, setup time). Only use for genuinely heavy operations (>100ms). For most async operations, use async/await instead.",
          "bestUse": "Parsing large JSON, image processing, complex calculations, cryptography, file compression"
        },
        "ar": {
          "question": "ما هي Isolates في Dart ومتى يجب استخدامها؟",
          "answer": "Isolates هي عمال مستقلون لهم كومة ذاكرة خاصة بهم. Dart أحادي الخيط لكنه يستخدم isolates للتوازي الحقيقي. على عكس الخيوط، isolates لا تشارك الذاكرة، تتواصل عبر تمرير الرسائل. الاستخدام: الحسابات الثقيلة (تحليل JSON الكبيرة، معالجة الصور، التشفير)، تجنب تعطل واجهة المستخدم. استخدم دالة ()compute للحالات البسيطة، أو أنشئ isolates يدويًا للسيناريوهات المعقدة.",
          "example": "// استخدام مساعد compute()\nimport 'package:flutter/foundation.dart';\n\nFuture<List<Photo>> parsePhotos(String responseBody) async {\n  return compute(parsePhotosInIsolate, responseBody);\n}\n\nList<Photo> parsePhotosInIsolate(String responseBody) {\n  final parsed = jsonDecode(responseBody).cast<Map<String, dynamic>>();\n  return parsed.map<Photo>((json) => Photo.fromJson(json)).toList();\n}\n\n// Isolate يدوي\nimport 'dart:isolate';\n\nvoid heavyTask(SendPort sendPort) {\n  // تنفيذ الحساب\n  sendPort.send(result);\n}\n\nfinal receivePort = ReceivePort();\nawait Isolate.spawn(heavyTask, receivePort.sendPort);\nfinal result = await receivePort.first;",
          "notes": "Isolates لها تكلفة إضافية (ذاكرة، وقت الإعداد). استخدمها فقط للعمليات الثقيلة حقًا (>100 مللي ثانية). لمعظم العمليات غير المتزامنة، استخدم async/await بدلاً من ذلك.",
          "bestUse": "تحليل JSON الكبيرة، معالجة الصور، الحسابات المعقدة، التشفير، ضغط الملفات"
        }
      }
    },
    {
      "id": "FLT-020",
      "difficulty": "advanced",
      "category": "nativePlatform",
      "type": "practical",
      "tags": [
        "methodChannels",
        "platformViews",
        "ffi"
      ],
      "content": {
        "en": {
          "question": "Explain platform integration methods: MethodChannel, EventChannel, and FFI.",
          "answer": "MethodChannel: Bidirectional communication with platform (iOS/Android) code. Async method calls. Use for invoking native APIs. EventChannel: Stream of events from native to Dart. Use for continuous data (sensor data, location updates). FFI (Foreign Function Interface): Call C libraries directly, synchronous, best performance. Use for performance-critical native code. PlatformViews: Embed native UI components in Flutter.",
          "example": "// MethodChannel\nstatic const platform = MethodChannel('com.example/battery');\nfinal int batteryLevel = await platform.invokeMethod('getBatteryLevel');\n\n// EventChannel\nstatic const eventChannel = EventChannel('com.example/sensor');\neventChannel.receiveBroadcastStream().listen((data) {\n  print('Sensor data: $data');\n});\n\n// FFI\nimport 'dart:ffi';\nimport 'package:ffi/ffi.dart';\n\ntypedef NativeAdd = Int32 Function(Int32 a, Int32 b);\ntypedef DartAdd = int Function(int a, int b);\n\nfinal dylib = DynamicLibrary.open('native_lib.so');\nfinal add = dylib.lookupFunction<NativeAdd, DartAdd>('add');\nprint(add(5, 3)); // Calls C function",
          "notes": "MethodChannel is most common. Use FFI for performance-critical operations. EventChannel for streaming data. Each requires platform-specific code (Swift/Kotlin).",
          "bestUse": "MethodChannel: camera, permissions, native APIs; EventChannel: sensors, location; FFI: performance-critical native libraries"
        },
        "ar": {
          "question": "اشرح طرق التكامل مع المنصة: MethodChannel و EventChannel و FFI.",
          "answer": "MethodChannel: اتصال ثنائي الاتجاه مع كود المنصة (iOS/Android). استدعاءات طرق غير متزامنة. استخدمه لاستدعاء واجهات برمجة التطبيقات الأصلية. EventChannel: تدفق الأحداث من الأصلي إلى Dart. استخدمه للبيانات المستمرة (بيانات المستشعر، تحديثات الموقع). FFI (واجهة الوظائف الأجنبية): استدعاء مكتبات C مباشرة، متزامن، أفضل أداء. استخدمه للكود الأصلي الحرج من حيث الأداء. PlatformViews: تضمين مكونات واجهة المستخدم الأصلية في Flutter.",
          "example": "// MethodChannel\nstatic const platform = MethodChannel('com.example/battery');\nfinal int batteryLevel = await platform.invokeMethod('getBatteryLevel');\n\n// EventChannel\nstatic const eventChannel = EventChannel('com.example/sensor');\neventChannel.receiveBroadcastStream().listen((data) {\n  print('بيانات المستشعر: $data');\n});\n\n// FFI\nimport 'dart:ffi';\nimport 'package:ffi/ffi.dart';\n\ntypedef NativeAdd = Int32 Function(Int32 a, Int32 b);\ntypedef DartAdd = int Function(int a, int b);\n\nfinal dylib = DynamicLibrary.open('native_lib.so');\nfinal add = dylib.lookupFunction<NativeAdd, DartAdd>('add');\nprint(add(5, 3)); // يستدعي دالة C",
          "notes": "MethodChannel هو الأكثر شيوعًا. استخدم FFI للعمليات الحرجة من حيث الأداء. EventChannel لبث البيانات. كل منها يتطلب كودًا خاصًا بالمنصة (Swift/Kotlin).",
          "bestUse": "MethodChannel: الكاميرا، الأذونات، واجهات برمجة التطبيقات الأصلية؛ EventChannel: المستشعرات، الموقع؛ FFI: المكتبات الأصلية الحرجة من حيث الأداء"
        }
      }
    },
    {
      "id": "FLT-021",
      "difficulty": "intermediate",
      "category": "animations",
      "type": "practical",
      "tags": [
        "animations"
      ],
      "content": {
        "en": {
          "question": "Explain different animation types in Flutter and when to use each.",
          "answer": "1) Implicit Animations: AnimatedContainer, AnimatedOpacity - automatic, simple property changes. 2) Explicit Animations: AnimationController, Tween - fine control, complex animations. 3) Hero Animations: Shared element transitions between routes. 4) Physics-based: SpringSimulation, realistic motion. 5) Rive/Lottie: Complex designer animations. Choose based on complexity needs.",
          "example": "// Implicit\nAnimatedContainer(\n  duration: Duration(seconds: 1),\n  width: isExpanded ? 200 : 100,\n  curve: Curves.easeInOut,\n);\n\n// Explicit\nclass MyWidget extends StatefulWidget {\n  State createState() => _MyWidgetState();\n}\nclass _MyWidgetState extends State<MyWidget> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _animation;\n  \n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: Duration(seconds: 2),\n      vsync: this,\n    );\n    _animation = Tween<double>(begin: 0, end: 1).animate(_controller);\n    _controller.forward();\n  }\n  \n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}",
          "notes": "Start with implicit animations for simplicity. Use explicit for complex, chained, or custom animations. Always dispose controllers.",
          "bestUse": "Implicit for simple UI feedback, explicit for complex sequences, Hero for navigation, physics for natural motion"
        },
        "ar": {
          "question": "اشرح أنواع الرسوم المتحركة المختلفة في Flutter ومتى تستخدم كل منها.",
          "answer": "1) الرسوم المتحركة الضمنية: AnimatedContainer، AnimatedOpacity - تلقائية، تغييرات خصائص بسيطة. 2) الرسوم المتحركة الصريحة: AnimationController، Tween - تحكم دقيق، رسوم متحركة معقدة. 3) رسوم Hero المتحركة: انتقالات العناصر المشتركة بين المسارات. 4) قائمة على الفيزياء: SpringSimulation، حركة واقعية. 5) Rive/Lottie: رسوم متحركة معقدة من المصممين. اختر بناءً على احتياجات التعقيد.",
          "example": "// ضمنية\nAnimatedContainer(\n  duration: Duration(seconds: 1),\n  width: isExpanded ? 200 : 100,\n  curve: Curves.easeInOut,\n);\n\n// صريحة\nclass MyWidget extends StatefulWidget {\n  State createState() => _MyWidgetState();\n}\nclass _MyWidgetState extends State<MyWidget> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _animation;\n  \n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: Duration(seconds: 2),\n      vsync: this,\n    );\n    _animation = Tween<double>(begin: 0, end: 1).animate(_controller);\n    _controller.forward();\n  }\n  \n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}",
          "notes": "ابدأ بالرسوم المتحركة الضمنية للبساطة. استخدم الصريحة للرسوم المتحركة المعقدة أو المتسلسلة أو المخصصة. تخلص دائمًا من وحدات التحكم.",
          "bestUse": "ضمنية لتعليقات واجهة المستخدم البسيطة، صريحة للتسلسلات المعقدة، Hero للتنقل، فيزيائية للحركة الطبيعية"
        }
      }
    },
    {
      "id": "FLT-022",
      "difficulty": "advanced",
      "category": "performance",
      "type": "debugging",
      "tags": [
        "optimization",
        "renderingOptimization",
        "memoryManagement"
      ],
      "content": {
        "en": {
          "question": "How do you identify and fix performance issues in Flutter apps?",
          "answer": "Tools: 1) Flutter DevTools (Performance, Memory, Network tabs). 2) Timeline view for frame rendering. 3) Memory profiler for leaks. 4) CPU profiler. Common issues: Unnecessary rebuilds (use const, keys), expensive build methods, large images, missing RepaintBoundary, ListView without builder, retained animations. Fixes: Use performance overlay, profile mode testing, optimize images, lazy loading, caching.",
          "example": "// Performance overlay\nvoid main() {\n  runApp(MyApp());\n  // Show performance overlay\n  // flutter run --profile\n}\n\n// Identify expensive builds\nclass MyWidget extends StatelessWidget {\n  Widget build(BuildContext context) {\n    print('Building MyWidget'); // Check rebuild frequency\n    return Container();\n  }\n}\n\n// Fix with const\nconst Text('Static'); // Won't rebuild\n\n// RepaintBoundary for isolation\nRepaintBoundary(\n  child: AnimatedWidget(),\n);",
          "notes": "Always profile in profile/release mode, not debug. Debug mode has overhead. Use Flutter DevTools Performance tab to record timeline.",
          "bestUse": "When app has jank, frame drops, or slow rendering. Essential before production release."
        },
        "ar": {
          "question": "كيف تحدد وتصلح مشاكل الأداء في تطبيقات Flutter؟",
          "answer": "الأدوات: 1) Flutter DevTools (علامات تبويب الأداء والذاكرة والشبكة). 2) عرض الجدول الزمني لعرض الإطارات. 3) مراقب الذاكرة للتسريبات. 4) مراقب المعالج. المشاكل الشائعة: عمليات إعادة بناء غير ضرورية (استخدم const، المفاتيح)، طرق بناء مكلفة، صور كبيرة، RepaintBoundary مفقودة، ListView بدون منشئ، رسوم متحركة محتفظ بها. الإصلاحات: استخدم تراكب الأداء، اختبار وضع الملف الشخصي، تحسين الصور، التحميل الكسول، التخزين المؤقت.",
          "example": "// تراكب الأداء\nvoid main() {\n  runApp(MyApp());\n  // إظهار تراكب الأداء\n  // flutter run --profile\n}\n\n// تحديد البناءات المكلفة\nclass MyWidget extends StatelessWidget {\n  Widget build(BuildContext context) {\n    print('بناء MyWidget'); // تحقق من تكرار إعادة البناء\n    return Container();\n  }\n}\n\n// الإصلاح باستخدام const\nconst Text('ثابت'); // لن يعاد بناؤه\n\n// RepaintBoundary للعزل\nRepaintBoundary(\n  child: AnimatedWidget(),\n);",
          "notes": "راقب الأداء دائمًا في وضع الملف الشخصي/الإصدار، وليس التصحيح. وضع التصحيح له تكلفة إضافية. استخدم علامة تبويب الأداء في Flutter DevTools لتسجيل الجدول الزمني.",
          "bestUse": "عندما يكون للتطبيق تعطل أو انخفاض في الإطارات أو عرض بطيء. أساسي قبل إصدار الإنتاج."
        }
      }
    },
    {
      "id": "FLT-023",
      "difficulty": "expert",
      "category": "designPatterns",
      "type": "architectural",
      "tags": [
        "bloc",
        "cubit",
        "observer"
      ],
      "content": {
        "en": {
          "question": "Implement BLoC pattern from scratch without using flutter_bloc package.",
          "answer": "BLoC (Business Logic Component) separates business logic from UI using streams. Input: Sink (events), Output: Stream (states). Create event classes, state classes, BLoC class with StreamController. UI sends events via sink, listens to states via stream. Dispose controllers properly.",
          "example": "// Events\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n\n// States\nclass CounterState {\n  final int count;\n  CounterState(this.count);\n}\n\n// BLoC\nclass CounterBloc {\n  int _count = 0;\n  \n  final _stateController = StreamController<CounterState>();\n  Stream<CounterState> get state => _stateController.stream;\n  \n  final _eventController = StreamController<CounterEvent>();\n  Sink<CounterEvent> get eventSink => _eventController.sink;\n  \n  CounterBloc() {\n    _eventController.stream.listen(_mapEventToState);\n  }\n  \n  void _mapEventToState(CounterEvent event) {\n    if (event is IncrementEvent) {\n      _count++;\n    } else if (event is DecrementEvent) {\n      _count--;\n    }\n    _stateController.sink.add(CounterState(_count));\n  }\n  \n  void dispose() {\n    _stateController.close();\n    _eventController.close();\n  }\n}\n\n// Usage in widget\nStreamBuilder<CounterState>(\n  stream: bloc.state,\n  builder: (context, snapshot) {\n    return Text('${snapshot.data?.count ?? 0}');\n  },\n)",
          "notes": "This is educational. In production, use flutter_bloc package which handles complexity, provides testing utilities, and follows best practices.",
          "bestUse": "Understanding BLoC architecture. For production, use flutter_bloc package."
        },
        "ar": {
          "question": "نفذ نمط BLoC من الصفر دون استخدام حزمة flutter_bloc.",
          "answer": "BLoC (مكون منطق الأعمال) يفصل منطق الأعمال عن واجهة المستخدم باستخدام التدفقات. الإدخال: Sink (الأحداث)، الإخراج: Stream (الحالات). أنشئ فئات الأحداث، فئات الحالة، فئة BLoC مع StreamController. واجهة المستخدم ترسل الأحداث عبر sink، تستمع للحالات عبر stream. تخلص من وحدات التحكم بشكل صحيح.",
          "example": "// الأحداث\nabstract class CounterEvent {}\nclass IncrementEvent extends CounterEvent {}\nclass DecrementEvent extends CounterEvent {}\n\n// الحالات\nclass CounterState {\n  final int count;\n  CounterState(this.count);\n}\n\n// BLoC\nclass CounterBloc {\n  int _count = 0;\n  \n  final _stateController = StreamController<CounterState>();\n  Stream<CounterState> get state => _stateController.stream;\n  \n  final _eventController = StreamController<CounterEvent>();\n  Sink<CounterEvent> get eventSink => _eventController.sink;\n  \n  CounterBloc() {\n    _eventController.stream.listen(_mapEventToState);\n  }\n  \n  void _mapEventToState(CounterEvent event) {\n    if (event is IncrementEvent) {\n      _count++;\n    } else if (event is DecrementEvent) {\n      _count--;\n    }\n    _stateController.sink.add(CounterState(_count));\n  }\n  \n  void dispose() {\n    _stateController.close();\n    _eventController.close();\n  }\n}\n\n// الاستخدام في الويدجت\nStreamBuilder<CounterState>(\n  stream: bloc.state,\n  builder: (context, snapshot) {\n    return Text('${snapshot.data?.count ?? 0}');\n  },\n)",
          "notes": "هذا تعليمي. في الإنتاج، استخدم حزمة flutter_bloc التي تتعامل مع التعقيد، توفر أدوات الاختبار، وتتبع أفضل الممارسات.",
          "bestUse": "فهم بنية BLoC. للإنتاج، استخدم حزمة flutter_bloc."
        }
      }
    },
    {
      "id": "FLT-024",
      "difficulty": "intermediate",
      "category": "modernFeatures",
      "type": "theoretical",
      "tags": [
        "material3"
      ],
      "content": {
        "en": {
          "question": "What is Material Design 3 (Material You) and how to implement it in Flutter?",
          "answer": "Material 3 is Google's latest design system with dynamic color, updated components, and adaptive design. Features: dynamic color from wallpaper, updated typography, new component designs. In Flutter 3.0+, use ThemeData with useMaterial3: true. Provides ColorScheme.fromSeed() for dynamic theming. New widgets: NavigationBar, NavigationDrawer, SegmentedButton, etc.",
          "example": "MaterialApp(\n  theme: ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: Colors.blue,\n      brightness: Brightness.light,\n    ),\n  ),\n  darkTheme: ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: Colors.blue,\n      brightness: Brightness.dark,\n    ),\n  ),\n);\n\n// New M3 widgets\nNavigationBar(\n  destinations: [\n    NavigationDestination(icon: Icon(Icons.home), label: 'Home'),\n  ],\n);",
          "notes": "Material 3 is default in Flutter 3.16+. Provides better accessibility, modern look. Some widgets have breaking changes from M2.",
          "bestUse": "All new Flutter apps should use Material 3 for modern design language and better theming capabilities."
        },
        "ar": {
          "question": "ما هو Material Design 3 (Material You) وكيفية تنفيذه في Flutter؟",
          "answer": "Material 3 هو أحدث نظام تصميم من Google مع لون ديناميكي ومكونات محدثة وتصميم تكيفي. الميزات: لون ديناميكي من الخلفية، طباعة محدثة، تصاميم مكونات جديدة. في Flutter 3.0+، استخدم ThemeData مع useMaterial3: true. يوفر ColorScheme.fromSeed() للتصميم الديناميكي. ويدجتات جديدة: NavigationBar، NavigationDrawer، SegmentedButton، إلخ.",
          "example": "MaterialApp(\n  theme: ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: Colors.blue,\n      brightness: Brightness.light,\n    ),\n  ),\n  darkTheme: ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: Colors.blue,\n      brightness: Brightness.dark,\n    ),\n  ),\n);\n\n// ويدجتات M3 الجديدة\nNavigationBar(\n  destinations: [\n    NavigationDestination(icon: Icon(Icons.home), label: 'الرئيسية'),\n  ],\n);",
          "notes": "Material 3 هو الافتراضي في Flutter 3.16+. يوفر إمكانية وصول أفضل ومظهر حديث. بعض الويدجتات لها تغييرات جذرية من M2.",
          "bestUse": "يجب أن تستخدم جميع تطبيقات Flutter الجديدة Material 3 للغة التصميم الحديثة وقدرات تصميم أفضل."
        }
      }
    },
    {
      "id": "FLT-025",
      "difficulty": "intermediate",
      "category": "security",
      "type": "practical",
      "tags": [
        "security"
      ],
      "content": {
        "en": {
          "question": "What are the best security practices for Flutter applications?",
          "answer": "1) Secure storage: Use flutter_secure_storage for sensitive data, never SharedPreferences. 2) API security: Use HTTPS only, certificate pinning, API keys in environment variables. 3) Code obfuscation: Enable obfuscation in release builds. 4) Jailbreak/root detection. 5) Secure authentication: OAuth 2.0, biometric auth. 6) Input validation. 7) Prevent screenshot in sensitive screens. 8) Use ProGuard/R8 for Android. 9) Encrypt local database.",
          "example": "// Secure storage\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nfinal storage = FlutterSecureStorage();\nawait storage.write(key: 'token', value: 'secret_token');\n\n// Build with obfuscation\nflutter build apk --obfuscate --split-debug-info=build/app/outputs/symbols\n\n// Certificate pinning with dio\nfinal dio = Dio();\n(dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) {\n  client.badCertificateCallback = (X509Certificate cert, String host, int port) {\n    return cert.sha256.toString() == 'expected_sha256';\n  };\n};\n\n// Prevent screenshots (Android)\nimport 'package:flutter_windowmanager/flutter_windowmanager.dart';\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_SECURE);",
          "notes": "Security is multi-layered. No single solution is sufficient. Always validate on backend too. Keep dependencies updated.",
          "bestUse": "Financial apps, healthcare apps, apps handling sensitive user data"
        },
        "ar": {
          "question": "ما هي أفضل ممارسات الأمان لتطبيقات Flutter؟",
          "answer": "1) التخزين الآمن: استخدم flutter_secure_storage للبيانات الحساسة، لا تستخدم SharedPreferences أبدًا. 2) أمان API: استخدم HTTPS فقط، تثبيت الشهادة، مفاتيح API في متغيرات البيئة. 3) إخفاء الكود: فعّل الإخفاء في بناءات الإصدار. 4) كشف كسر الحماية/الجذر. 5) مصادقة آمنة: OAuth 2.0، مصادقة بيومترية. 6) التحقق من صحة الإدخال. 7) منع لقطة الشاشة في الشاشات الحساسة. 8) استخدم ProGuard/R8 لـ Android. 9) تشفير قاعدة البيانات المحلية.",
          "example": "// التخزين الآمن\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nfinal storage = FlutterSecureStorage();\nawait storage.write(key: 'token', value: 'secret_token');\n\n// البناء مع الإخفاء\nflutter build apk --obfuscate --split-debug-info=build/app/outputs/symbols\n\n// تثبيت الشهادة مع dio\nfinal dio = Dio();\n(dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) {\n  client.badCertificateCallback = (X509Certificate cert, String host, int port) {\n    return cert.sha256.toString() == 'expected_sha256';\n  };\n};\n\n// منع لقطات الشاشة (Android)\nimport 'package:flutter_windowmanager/flutter_windowmanager.dart';\nawait FlutterWindowManager.addFlags(FlutterWindowManager.FLAG_SECURE);",
          "notes": "الأمان متعدد الطبقات. لا يوجد حل واحد كافٍ. تحقق دائمًا من الخلفية أيضًا. حافظ على تحديث التبعيات.",
          "bestUse": "التطبيقات المالية، تطبيقات الرعاية الصحية، التطبيقات التي تتعامل مع بيانات المستخدم الحساسة"
        }
      }
    },
    {
      "id": "FLT-026",
      "difficulty": "advanced",
      "category": "deployment",
      "type": "practical",
      "tags": [
        "flavors",
        "ci_cd",
        "appSigning"
      ],
      "content": {
        "en": {
          "question": "Explain app flavors in Flutter and how to set them up for different environments.",
          "answer": "Flavors allow multiple app variants (dev, staging, production) from one codebase. Different app IDs, icons, API endpoints per flavor. Setup involves: 1) Android: Build variants in build.gradle, 2) iOS: Schemes in Xcode, 3) Dart: Environment variables or flavor-specific entry points. Use --flavor flag when building.",
          "example": "// Android build.gradle\nandroid {\n  flavorDimensions \"environment\"\n  productFlavors {\n    dev {\n      dimension \"environment\"\n      applicationIdSuffix \".dev\"\n      versionNameSuffix \"-dev\"\n    }\n    prod {\n      dimension \"environment\"\n    }\n  }\n}\n\n// Dart entry point approach\n// main_dev.dart\nvoid main() => runApp(MyApp(env: Environment.dev));\n// main_prod.dart\nvoid main() => runApp(MyApp(env: Environment.prod));\n\n// Build commands\nflutter run --flavor dev -t lib/main_dev.dart\nflutter build apk --flavor prod -t lib/main_prod.dart",
          "notes": "Flavors prevent accidentally deploying dev builds to production. Essential for teams. Use with CI/CD for automated builds.",
          "bestUse": "Apps with multiple environments, testing different backends, white-label apps"
        },
        "ar": {
          "question": "اشرح نكهات التطبيق (flavors) في Flutter وكيفية إعدادها لبيئات مختلفة.",
          "answer": "النكهات تسمح بمتغيرات تطبيق متعددة (dev، staging، production) من قاعدة كود واحدة. معرفات تطبيق مختلفة، أيقونات، نقاط نهاية API لكل نكهة. الإعداد يتضمن: 1) Android: متغيرات البناء في build.gradle، 2) iOS: المخططات في Xcode، 3) Dart: متغيرات البيئة أو نقاط دخول خاصة بالنكهة. استخدم علامة --flavor عند البناء.",
          "example": "// Android build.gradle\nandroid {\n  flavorDimensions \"environment\"\n  productFlavors {\n    dev {\n      dimension \"environment\"\n      applicationIdSuffix \".dev\"\n      versionNameSuffix \"-dev\"\n    }\n    prod {\n      dimension \"environment\"\n    }\n  }\n}\n\n// نهج نقطة دخول Dart\n// main_dev.dart\nvoid main() => runApp(MyApp(env: Environment.dev));\n// main_prod.dart\nvoid main() => runApp(MyApp(env: Environment.prod));\n\n// أوامر البناء\nflutter run --flavor dev -t lib/main_dev.dart\nflutter build apk --flavor prod -t lib/main_prod.dart",
          "notes": "النكهات تمنع نشر بناءات dev إلى الإنتاج عن طريق الخطأ. ضرورية للفرق. استخدمها مع CI/CD للبناءات التلقائية.",
          "bestUse": "التطبيقات ذات البيئات المتعددة، اختبار خوادم خلفية مختلفة، تطبيقات العلامة البيضاء"
        }
      }
    },
    {
      "id": "FLT-027",
      "difficulty": "intermediate",
      "category": "basic",
      "type": "theoretical",
      "tags": [
        "inheritedWidget",
        "buildContext"
      ],
      "content": {
        "en": {
          "question": "What is InheritedWidget and how does it work?",
          "answer": "InheritedWidget is a base class for widgets that efficiently propagate information down the tree. When data changes, only widgets that depend on it rebuild. Foundation of state management (Provider wraps this). Access via BuildContext using dependOnInheritedWidgetOfExactType. Use updateShouldNotify to control when dependents rebuild.",
          "example": "class MyInheritedWidget extends InheritedWidget {\n  final int data;\n  \n  MyInheritedWidget({\n    required this.data,\n    required Widget child,\n  }) : super(child: child);\n  \n  static MyInheritedWidget? of(BuildContext context) {\n    return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();\n  }\n  \n  @override\n  bool updateShouldNotify(MyInheritedWidget oldWidget) {\n    return oldWidget.data != data;\n  }\n}\n\n// Usage\nfinal inheritedWidget = MyInheritedWidget.of(context);\nprint(inheritedWidget?.data);",
          "notes": "InheritedWidget is low-level. Most developers use higher-level wrappers like Provider. Understanding it helps debug state management issues.",
          "bestUse": "Building custom state management solutions, understanding Provider internals"
        },
        "ar": {
          "question": "ما هو InheritedWidget وكيف يعمل؟",
          "answer": "InheritedWidget هو فئة أساسية للويدجتات التي تنشر المعلومات بكفاءة أسفل الشجرة. عندما تتغير البيانات، تُعاد بناء الويدجتات التي تعتمد عليها فقط. أساس إدارة الحالة (Provider يغلف هذا). الوصول عبر BuildContext باستخدام dependOnInheritedWidgetOfExactType. استخدم updateShouldNotify للتحكم في وقت إعادة بناء التبعيات.",
          "example": "class MyInheritedWidget extends InheritedWidget {\n  final int data;\n  \n  MyInheritedWidget({\n    required this.data,\n    required Widget child,\n  }) : super(child: child);\n  \n  static MyInheritedWidget? of(BuildContext context) {\n    return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();\n  }\n  \n  @override\n  bool updateShouldNotify(MyInheritedWidget oldWidget) {\n    return oldWidget.data != data;\n  }\n}\n\n// الاستخدام\nfinal inheritedWidget = MyInheritedWidget.of(context);\nprint(inheritedWidget?.data);",
          "notes": "InheritedWidget منخفض المستوى. معظم المطورين يستخدمون أغلفة عالية المستوى مثل Provider. فهمه يساعد في تصحيح مشاكل إدارة الحالة.",
          "bestUse": "بناء حلول إدارة حالة مخصصة، فهم آليات Provider الداخلية"
        }
      }
    },
    {
      "id": "FLT-028",
      "difficulty": "basic",
      "category": "basic",
      "type": "practical",
      "tags": [
        "dartBasics",
        "extensions"
      ],
      "content": {
        "en": {
          "question": "What are Extension Methods in Dart and provide useful examples.",
          "answer": "Extension methods add functionality to existing types without modifying them or creating subclasses. Introduced in Dart 2.7. Useful for adding utility methods to built-in types. Can extend any type including third-party classes.",
          "example": "// String extensions\nextension StringExtensions on String {\n  bool get isValidEmail {\n    return RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$').hasMatch(this);\n  }\n  \n  String capitalize() {\n    if (isEmpty) return this;\n    return this[0].toUpperCase() + substring(1);\n  }\n}\n\n// Usage\nprint('hello'.capitalize()); // 'Hello'\nprint('test@email.com'.isValidEmail); // true\n\n// Number extensions\nextension IntExtensions on int {\n  Duration get seconds => Duration(seconds: this);\n  Duration get minutes => Duration(minutes: this);\n}\n\nawait Future.delayed(5.seconds);\n\n// DateTime extensions\nextension DateTimeExtensions on DateTime {\n  bool get isToday {\n    final now = DateTime.now();\n    return year == now.year && month == now.month && day == now.day;\n  }\n}",
          "notes": "Extensions are resolved statically at compile time. Name conflicts resolved by explicit extension name or import prefix.",
          "bestUse": "Utility functions, improving code readability, adding domain-specific methods to existing types"
        },
        "ar": {
          "question": "ما هي Extension Methods في Dart وقدم أمثلة مفيدة.",
          "answer": "طرق التمديد تضيف وظائف إلى الأنواع الموجودة دون تعديلها أو إنشاء فئات فرعية. تم تقديمها في Dart 2.7. مفيدة لإضافة طرق مساعدة إلى الأنواع المدمجة. يمكن توسيع أي نوع بما في ذلك فئات الطرف الثالث.",
          "example": "// امتدادات String\nextension StringExtensions on String {\n  bool get isValidEmail {\n    return RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$').hasMatch(this);\n  }\n  \n  String capitalize() {\n    if (isEmpty) return this;\n    return this[0].toUpperCase() + substring(1);\n  }\n}\n\n// الاستخدام\nprint('مرحبا'.capitalize()); // 'مرحبا'\nprint('test@email.com'.isValidEmail); // true\n\n// امتدادات Number\nextension IntExtensions on int {\n  Duration get seconds => Duration(seconds: this);\n  Duration get minutes => Duration(minutes: this);\n}\n\nawait Future.delayed(5.seconds);\n\n// امتدادات DateTime\nextension DateTimeExtensions on DateTime {\n  bool get isToday {\n    final now = DateTime.now();\n    return year == now.year && month == now.month && day == now.day;\n  }\n}",
          "notes": "الامتدادات تُحل بشكل ثابت في وقت الترجمة. تُحل تعارضات الأسماء عن طريق اسم الامتداد الصريح أو بادئة الاستيراد.",
          "bestUse": "الوظائف المساعدة، تحسين قابلية قراءة الكود، إضافة طرق خاصة بالمجال إلى الأنواع الموجودة"
        }
      }
    },
    {
      "id": "FLT-029",
      "difficulty": "advanced",
      "category": "algorithms",
      "type": "coding",
      "tags": [
        "algorithms",
        "dataStructures"
      ],
      "content": {
        "en": {
          "question": "Implement a debounce function in Dart for search optimization.",
          "answer": "Debouncing delays function execution until after a specified time has elapsed since the last call. Essential for search fields to avoid excessive API calls. Use Timer to implement.",
          "example": "import 'dart:async';\n\nclass Debouncer {\n  final Duration delay;\n  Timer? _timer;\n  \n  Debouncer({required this.delay});\n  \n  void call(void Function() action) {\n    _timer?.cancel();\n    _timer = Timer(delay, action);\n  }\n  \n  void dispose() {\n    _timer?.cancel();\n  }\n}\n\n// Usage in search\nclass SearchWidget extends StatefulWidget {\n  @override\n  State<SearchWidget> createState() => _SearchWidgetState();\n}\n\nclass _SearchWidgetState extends State<SearchWidget> {\n  final _debouncer = Debouncer(delay: Duration(milliseconds: 500));\n  \n  void _onSearchChanged(String query) {\n    _debouncer.call(() {\n      // Perform search API call\n      performSearch(query);\n    });\n  }\n  \n  @override\n  void dispose() {\n    _debouncer.dispose();\n    super.dispose();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      onChanged: _onSearchChanged,\n    );\n  }\n}",
          "notes": "Also consider throttling (execute at most once per time period) for different use cases like scroll events.",
          "bestUse": "Search fields, autocomplete, text input validation, API calls triggered by user input"
        },
        "ar": {
          "question": "نفذ دالة debounce في Dart لتحسين البحث.",
          "answer": "Debouncing يؤخر تنفيذ الدالة حتى بعد مرور وقت محدد منذ آخر استدعاء. ضروري لحقول البحث لتجنب استدعاءات API الزائدة. استخدم Timer للتنفيذ.",
          "example": "import 'dart:async';\n\nclass Debouncer {\n  final Duration delay;\n  Timer? _timer;\n  \n  Debouncer({required this.delay});\n  \n  void call(void Function() action) {\n    _timer?.cancel();\n    _timer = Timer(delay, action);\n  }\n  \n  void dispose() {\n    _timer?.cancel();\n  }\n}\n\n// الاستخدام في البحث\nclass SearchWidget extends StatefulWidget {\n  @override\n  State<SearchWidget> createState() => _SearchWidgetState();\n}\n\nclass _SearchWidgetState extends State<SearchWidget> {\n  final _debouncer = Debouncer(delay: Duration(milliseconds: 500));\n  \n  void _onSearchChanged(String query) {\n    _debouncer.call(() {\n      // تنفيذ استدعاء API البحث\n      performSearch(query);\n    });\n  }\n  \n  @override\n  void dispose() {\n    _debouncer.dispose();\n    super.dispose();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      onChanged: _onSearchChanged,\n    );\n  }\n}",
          "notes": "فكر أيضًا في throttling (تنفيذ مرة واحدة على الأكثر لكل فترة زمنية) لحالات استخدام مختلفة مثل أحداث التمرير.",
          "bestUse": "حقول البحث، الإكمال التلقائي، التحقق من صحة إدخال النص، استدعاءات API المشغلة بواسطة إدخال المستخدم"
        }
      }
    },
    {
      "id": "FLT-030",
      "difficulty": "expert",
      "category": "performance",
      "type": "architectural",
      "tags": [
        "caching",
        "optimization"
      ],
      "content": {
        "en": {
          "question": "Design a comprehensive caching strategy for a Flutter app.",
          "answer": "Multi-layer caching: 1) Memory cache (in-memory Map, LRU cache) for frequently accessed data. 2) Disk cache (Hive, Isar) for persistent data. 3) Network cache (cache-control headers). 4) Image cache (cached_network_image). Implement cache invalidation strategies: TTL (time-to-live), LRU (least recently used), manual invalidation. Use Cache-Aside pattern.",
          "example": "// Multi-layer cache implementation\nclass CacheService<T> {\n  final Map<String, CacheEntry<T>> _memoryCache = {};\n  final Box<String> _diskCache; // Hive box\n  final Duration ttl;\n  final int maxMemoryItems;\n  \n  CacheService({\n    required this._diskCache,\n    this.ttl = const Duration(hours: 1),\n    this.maxMemoryItems = 100,\n  });\n  \n  Future<T?> get(String key, Future<T> Function() fetcher) async {\n    // 1. Check memory cache\n    if (_memoryCache.containsKey(key)) {\n      final entry = _memoryCache[key]!;\n      if (!entry.isExpired) {\n        return entry.value;\n      }\n      _memoryCache.remove(key);\n    }\n    \n    // 2. Check disk cache\n    final diskData = _diskCache.get(key);\n    if (diskData != null) {\n      final value = deserialize(diskData);\n      _addToMemoryCache(key, value);\n      return value;\n    }\n    \n    // 3. Fetch from network\n    final value = await fetcher();\n    await _cache(key, value);\n    return value;\n  }\n  \n  Future<void> _cache(String key, T value) async {\n    _addToMemoryCache(key, value);\n    await _diskCache.put(key, serialize(value));\n  }\n  \n  void _addToMemoryCache(String key, T value) {\n    if (_memoryCache.length >= maxMemoryItems) {\n      // Remove oldest\n      final oldestKey = _memoryCache.keys.first;\n      _memoryCache.remove(oldestKey);\n    }\n    _memoryCache[key] = CacheEntry(value, DateTime.now().add(ttl));\n  }\n}\n\nclass CacheEntry<T> {\n  final T value;\n  final DateTime expiryTime;\n  \n  CacheEntry(this.value, this.expiryTime);\n  \n  bool get isExpired => DateTime.now().isAfter(expiryTime);\n}",
          "notes": "Balance between memory usage and performance. Monitor cache hit rates. Implement cache warming for critical data.",
          "bestUse": "Apps with frequent API calls, image-heavy apps, apps needing offline support"
        },
        "ar": {
          "question": "صمم استراتيجية تخزين مؤقت شاملة لتطبيق Flutter.",
          "answer": "التخزين المؤقت متعدد الطبقات: 1) ذاكرة التخزين المؤقت (Map في الذاكرة، ذاكرة تخزين مؤقت LRU) للبيانات التي يتم الوصول إليها بشكل متكرر. 2) ذاكرة التخزين المؤقت للقرص (Hive، Isar) للبيانات المستمرة. 3) ذاكرة التخزين المؤقت للشبكة (رؤوس cache-control). 4) ذاكرة التخزين المؤقت للصور (cached_network_image). نفذ استراتيجيات إبطال ذاكرة التخزين المؤقت: TTL (وقت البقاء)، LRU (الأقل استخدامًا مؤخرًا)، الإبطال اليدوي. استخدم نمط Cache-Aside.",
          "example": "// تنفيذ ذاكرة تخزين مؤقت متعددة الطبقات\nclass CacheService<T> {\n  final Map<String, CacheEntry<T>> _memoryCache = {};\n  final Box<String> _diskCache; // Hive box\n  final Duration ttl;\n  final int maxMemoryItems;\n  \n  CacheService({\n    required this._diskCache,\n    this.ttl = const Duration(hours: 1),\n    this.maxMemoryItems = 100,\n  });\n  \n  Future<T?> get(String key, Future<T> Function() fetcher) async {\n    // 1. تحقق من ذاكرة التخزين المؤقت\n    if (_memoryCache.containsKey(key)) {\n      final entry = _memoryCache[key]!;\n      if (!entry.isExpired) {\n        return entry.value;\n      }\n      _memoryCache.remove(key);\n    }\n    \n    // 2. تحقق من ذاكرة التخزين المؤقت للقرص\n    final diskData = _diskCache.get(key);\n    if (diskData != null) {\n      final value = deserialize(diskData);\n      _addToMemoryCache(key, value);\n      return value;\n    }\n    \n    // 3. جلب من الشبكة\n    final value = await fetcher();\n    await _cache(key, value);\n    return value;\n  }\n  \n  Future<void> _cache(String key, T value) async {\n    _addToMemoryCache(key, value);\n    await _diskCache.put(key, serialize(value));\n  }\n  \n  void _addToMemoryCache(String key, T value) {\n    if (_memoryCache.length >= maxMemoryItems) {\n      // إزالة الأقدم\n      final oldestKey = _memoryCache.keys.first;\n      _memoryCache.remove(oldestKey);\n    }\n    _memoryCache[key] = CacheEntry(value, DateTime.now().add(ttl));\n  }\n}\n\nclass CacheEntry<T> {\n  final T value;\n  final DateTime expiryTime;\n  \n  CacheEntry(this.value, this.expiryTime);\n  \n  bool get isExpired => DateTime.now().isAfter(expiryTime);\n}",
          "notes": "التوازن بين استخدام الذاكرة والأداء. راقب معدلات نجاح ذاكرة التخزين المؤقت. نفذ تسخين ذاكرة التخزين المؤقت للبيانات الحرجة.",
          "bestUse": "التطبيقات ذات استدعاءات API المتكررة، التطبيقات كثيفة الصور، التطبيقات التي تحتاج دعم عدم الاتصال"
        }
      }
    }
  ]
}